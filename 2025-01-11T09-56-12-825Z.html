<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Document</title>
    <link rel="stylesheet" href="./style.css" />
  </head>

  <body class="markdown-body">
    <header class="container">
      <!-- * title * -->
      <h1>Remark AST Plugin Tutorial</h1>
    </header>

    <div class="content container">
      <div class="bubble user">
        how to write a plugin to traverse an ast tree in remark
      </div>
      <div class="bubble">
        <p>
          To write a plugin that traverses an AST (Abstract Syntax Tree) in
          <strong>Remark</strong>, you can create a
          <strong>Remark plugin</strong> using its unified API. Here's a
          step-by-step guide:
        </p>
        <hr />
        <h3 id="1-set-up-a-new-project">
          1. <strong>Set up a new project</strong>
        </h3>
        <p>
          Make sure you have <code>remark</code> and related packages installed:
        </p>
        <pre><code class="bash language-bash">npm install remark</code></pre>
        <p>If you need additional utilities, install:</p>
        <pre><code class="bash language-bash">npm install unified visit</code></pre>
        <hr />
        <h3 id="2-understand-the-ast-structure">
          2. <strong>Understand the AST structure</strong>
        </h3>
        <p>
          The AST generated by Remark follows the
          <a href="https://github.com/syntax-tree/mdast">MDAST specification</a
          >. Nodes have a <code>type</code> (e.g., <code>paragraph</code>,
          <code>heading</code>, <code>list</code>), and may contain children.
        </p>
        <hr />
        <h3 id="3-write-the-plugin">3. <strong>Write the Plugin</strong></h3>
        <p>
          A Remark plugin is a function that takes a syntax tree
          (<code>ast</code>) and performs operations on it. Use the
          <code>visit</code> utility to traverse the tree.
        </p>
        <p>Here's an example of a plugin:</p>
        <h4 id="example-logging-all-headings-in-a-markdown-file">
          Example: Logging all headings in a Markdown file
        </h4>
        <pre><code class="javascript language-javascript">const visit = require('unist-util-visit');

function myRemarkPlugin() {
  return (tree) =&gt; {
    // Traverse the AST
    visit(tree, 'heading', (node) =&gt; {
      console.log(`Found a heading with depth ${node.depth}`);
      console.log(`Text: ${node.children.map((child) =&gt; child.value).join('')}`);
    });
  };
}

module.exports = myRemarkPlugin;</code></pre>
        <hr />
        <h3 id="4-use-the-plugin">4. <strong>Use the Plugin</strong></h3>
        <p>Apply the plugin to a Markdown file:</p>
        <pre><code class="javascript language-javascript">const remark = require('remark');
const myRemarkPlugin = require('./myRemarkPlugin');

const markdown = `
# Heading 1
This is a paragraph.

## Heading 2
Another paragraph.
`;

remark()
  .use(myRemarkPlugin)
  .process(markdown, (err, file) =&gt; {
    if (err) throw err;
    console.log(String(file));
  });</code></pre>
        <hr />
        <h3 id="5-advanced-traversal">
          5. <strong>Advanced Traversal</strong>
        </h3>
        <ul>
          <li>Use <code>unist-util-visit</code> for selective traversal.</li>
        </ul>
        <pre><code class="javascript language-javascript">  visit(tree, 'paragraph', (node) =&gt; {
    console.log('Found a paragraph:', node);
  });</code></pre>
        <ul>
          <li>
            <p>
              Use <code>unist-util-visit-parents</code> if you need to know
              parent nodes.
            </p>
          </li>
          <li>
            <p>
              Use <code>unist-util-modify-children</code> for direct child
              modification.
            </p>
          </li>
        </ul>
        <hr />
        <h3 id="6-modify-the-ast">6. <strong>Modify the AST</strong></h3>
        <p>
          You can modify the AST within the <code>visit</code> callback. For
          example, adding text to all headings:
        </p>
        <pre><code class="javascript language-javascript">visit(tree, 'heading', (node) =&gt; {
  node.children.push({
    type: 'text',
    value: ' (modified)',
  });
});</code></pre>
        <hr />
        <h3 id="7-combine-plugins">7. <strong>Combine Plugins</strong></h3>
        <p>You can chain multiple plugins using <code>remark().use()</code>.</p>
        <hr />
        <h3 id="8-testing">8. <strong>Testing</strong></h3>
        <p>
          Use <code>remark-cli</code> or integrate your plugin in a larger build
          pipeline for testing.
        </p>
        <pre><code class="bash language-bash">npm install remark-cli
remark -u ./myRemarkPlugin input.md</code></pre>
        <hr />
        <h3 id="tips">Tips:</h3>
        <ul>
          <li>
            Always refer to the
            <a href="https://github.com/syntax-tree/mdast"
              >MDAST specification</a
            >
            to understand node types and their structure.
          </li>
          <li>
            Use <code>unist-util-visit</code> for most traversal needs; it's the
            go-to utility for working with unified ASTs.
          </li>
        </ul>
        <p>Let me know if you'd like examples for specific use cases! 🚀</p>
      </div>
      <div class="bubble user">how to then maniuplate the output ?</div>
      <div class="bubble">
        <p>
          Manipulating the output in a <strong>Remark plugin</strong> involves
          modifying the AST nodes during traversal. After you make changes to
          the AST, the updated structure will be reflected in the output
          Markdown.
        </p>
        <p>Here’s how to manipulate the output step-by-step:</p>
        <hr />
        <h3 id="1-modify-nodes">1. <strong>Modify Nodes</strong></h3>
        <p>
          When traversing the AST, you can directly change node properties (like
          <code>value</code> for text nodes) or structure (like adding,
          removing, or reordering nodes).
        </p>
        <p>For example, let's transform all headings to uppercase:</p>
        <pre><code class="javascript language-javascript">const visit = require('unist-util-visit');

function transformHeadingsToUppercase() {
  return (tree) =&gt; {
    visit(tree, 'heading', (node) =&gt; {
      node.children.forEach((child) =&gt; {
        if (child.type === 'text') {
          child.value = child.value.toUpperCase();
        }
      });
    });
  };
}

module.exports = transformHeadingsToUppercase;</code></pre>
        <hr />
        <h3 id="2-add-nodes">2. <strong>Add Nodes</strong></h3>
        <p>
          You can insert additional nodes into the AST. For example, let's add a
          note before every heading:
        </p>
        <pre><code class="javascript language-javascript">const visit = require('unist-util-visit');

function addNoteBeforeHeadings() {
  return (tree) =&gt; {
    visit(tree, 'heading', (node, index, parent) =&gt; {
      const noteNode = {
        type: 'paragraph',
        children: [
          {
            type: 'text',
            value: 'Note: This section is important!',
          },
        ],
      };

      parent.children.splice(index, 0, noteNode); // Insert the note before the heading
    });
  };
}

module.exports = addNoteBeforeHeadings;</code></pre>
        <hr />
        <h3 id="3-remove-nodes">3. <strong>Remove Nodes</strong></h3>
        <p>To remove a node, simply splice it out of its parent:</p>
        <pre><code class="javascript language-javascript">const visit = require('unist-util-visit');

function removeParagraphs() {
  return (tree) =&gt; {
    visit(tree, 'paragraph', (node, index, parent) =&gt; {
      parent.children.splice(index, 1); // Remove the paragraph node
    });
  };
}

module.exports = removeParagraphs;</code></pre>
        <hr />
        <h3 id="4-reorder-nodes">4. <strong>Reorder Nodes</strong></h3>
        <p>
          Reordering involves rearranging nodes in the
          <code>parent.children</code> array. For example, reversing the order
          of all headings:
        </p>
        <pre><code class="javascript language-javascript">const visit = require('unist-util-visit');

function reverseHeadings() {
  return (tree) =&gt; {
    const headings = [];

    visit(tree, 'heading', (node, index, parent) =&gt; {
      headings.push({ node, index, parent });
    });

    // Reverse headings in their parents
    headings.reverse().forEach(({ node, index, parent }) =&gt; {
      parent.children.splice(index, 1); // Remove the heading
      parent.children.push(node); // Add it back at the end
    });
  };
}

module.exports = reverseHeadings;</code></pre>
        <hr />
        <h3 id="5-update-metadata">5. <strong>Update Metadata</strong></h3>
        <p>
          You can store additional information or metadata in a custom format.
          For example, appending metadata to the tree:
        </p>
        <pre><code class="javascript language-javascript">function addMetadata() {
  return (tree) =&gt; {
    tree.children.push({
      type: 'html', // Add an HTML comment as metadata
      value: '&lt;!-- Generated by My Remark Plugin --&gt;',
    });
  };
}

module.exports = addMetadata;</code></pre>
        <hr />
        <h3 id="6-change-output-format">
          6. <strong>Change Output Format</strong>
        </h3>
        <p>
          If you need to generate specific output, such as converting the
          Markdown to HTML, integrate with <strong>rehype</strong> or stringify
          the Markdown.
        </p>
        <h4 id="markdown-to-html-example">Markdown to HTML Example:</h4>
        <pre><code class="javascript language-javascript">const remark = require('remark');
const html = require('remark-html');

remark()
  .use(html)
  .process('# Hello World', (err, file) =&gt; {
    if (err) throw err;
    console.log(String(file)); // Outputs HTML
  });</code></pre>
        <hr />
        <h3 id="7-multiple-changes">7. <strong>Multiple Changes</strong></h3>
        <p>
          You can chain multiple changes in a single plugin or combine plugins:
        </p>
        <pre><code class="javascript language-javascript">const visit = require('unist-util-visit');

function myCustomTransformations() {
  return (tree) =&gt; {
    // Change headings to uppercase
    visit(tree, 'heading', (node) =&gt; {
      node.children.forEach((child) =&gt; {
        if (child.type === 'text') {
          child.value = child.value.toUpperCase();
        }
      });
    });

    // Remove all paragraphs
    visit(tree, 'paragraph', (node, index, parent) =&gt; {
      parent.children.splice(index, 1);
    });
  };
}

module.exports = myCustomTransformations;</code></pre>
        <hr />
        <h3 id="8-save-or-use-the-manipulated-output">
          8. <strong>Save or Use the Manipulated Output</strong>
        </h3>
        <p>Finally, process and retrieve the updated Markdown:</p>
        <pre><code class="javascript language-javascript">const remark = require('remark');
const myCustomTransformations = require('./myCustomTransformations');

const markdown = `
# Heading 1
This is a paragraph.

## Heading 2
Another paragraph.
`;

remark()
  .use(myCustomTransformations)
  .process(markdown, (err, file) =&gt; {
    if (err) throw err;
    console.log(String(file)); // Outputs the transformed Markdown
  });</code></pre>
        <hr />
        <h3 id="final-notes">Final Notes</h3>
        <ul>
          <li>
            Always test your plugins with different Markdown inputs to ensure
            robustness.
          </li>
          <li>
            If working with HTML, use <strong>rehype</strong> for AST
            transformation at the HTML level.
          </li>
          <li>Follow the MDAST and Remark documentation for best practices.</li>
        </ul>
        <p>
          Let me know if you’d like specific help with any manipulation tasks!
          🚀
        </p>
      </div>
      <div class="bubble user">No I intend to add a block to it</div>
      <div class="bubble">
        <p>
          Adding a custom block to the Markdown content is straightforward when
          working with a <strong>Remark plugin</strong>. Here's how to do it:
        </p>
        <hr />
        <h3 id="example-adding-a-custom-block">
          Example: Adding a Custom Block
        </h3>
        <p>
          Let’s add a custom block, like a "callout" or "notice" block, to the
          Markdown content. The new block will be inserted as a node in the AST,
          and Remark will render it when the tree is processed.
        </p>
        <hr />
        <h3 id="1-define-the-plugin">1. <strong>Define the Plugin</strong></h3>
        <p>
          Here’s a plugin that adds a custom block at the beginning of the
          Markdown document:
        </p>
        <pre><code class="javascript language-javascript">function addCustomBlock() {
  return (tree) =&gt; {
    const customBlockNode = {
      type: 'paragraph', // Defines the block type; change this as needed
      children: [
        {
          type: 'text',
          value: '🚀 This is a custom callout block added by the plugin!',
        },
      ],
    };

    // Insert the custom block at the beginning of the document
    tree.children.unshift(customBlockNode);
  };
}

module.exports = addCustomBlock;</code></pre>
        <hr />
        <h3 id="2-use-the-plugin">2. <strong>Use the Plugin</strong></h3>
        <p>Apply the plugin to some Markdown content:</p>
        <pre><code class="javascript language-javascript">const remark = require('remark');
const addCustomBlock = require('./addCustomBlock');

const markdown = `
# Heading 1
This is some content.
`;

remark()
  .use(addCustomBlock)
  .process(markdown, (err, file) =&gt; {
    if (err) throw err;
    console.log(String(file)); // Outputs the modified Markdown
  });</code></pre>
        <p>The output will be:</p>
        <pre><code class="markdown language-markdown">🚀 This is a custom callout block added by the plugin!

# Heading 1
This is some content.</code></pre>
        <hr />
        <h3 id="3-add-a-custom-block-in-a-specific-location">
          3. <strong>Add a Custom Block in a Specific Location</strong>
        </h3>
        <p>
          If you want to add the block at a specific location (e.g., after the
          first heading), modify the plugin logic:
        </p>
        <pre><code class="javascript language-javascript">const visit = require('unist-util-visit');

function addBlockAfterFirstHeading() {
  return (tree) =&gt; {
    let blockAdded = false;

    visit(tree, 'heading', (node, index, parent) =&gt; {
      if (!blockAdded) {
        const customBlockNode = {
          type: 'paragraph',
          children: [
            {
              type: 'text',
              value: '📌 This block appears after the first heading.',
            },
          ],
        };

        parent.children.splice(index + 1, 0, customBlockNode); // Insert after the heading
        blockAdded = true;
      }
    });
  };
}

module.exports = addBlockAfterFirstHeading;</code></pre>
        <p>
          This ensures that the custom block is added right after the first
          heading in the document.
        </p>
        <hr />
        <h3 id="4-custom-block-as-html">
          4. <strong>Custom Block as HTML</strong>
        </h3>
        <p>
          If you want your custom block to include HTML, you can use an
          <code>html</code> node:
        </p>
        <pre><code class="javascript language-javascript">function addHtmlBlock() {
  return (tree) =&gt; {
    const htmlBlockNode = {
      type: 'html',
      value: '&lt;div class="custom-block"&gt;🔥 Custom HTML Block&lt;/div&gt;',
    };

    tree.children.push(htmlBlockNode); // Add it at the end
  };
}

module.exports = addHtmlBlock;</code></pre>
        <p>
          The resulting Markdown file will include the custom HTML directly:
        </p>
        <pre><code class="markdown language-markdown"># Heading 1

This is some content.

&lt;div class="custom-block"&gt;🔥 Custom HTML Block&lt;/div&gt;</code></pre>
        <hr />
        <h3 id="5-customizing-block-based-on-node-context">
          5. <strong>Customizing Block Based on Node Context</strong>
        </h3>
        <p>
          You can make the block content dynamic by examining the AST during
          traversal. For example, appending a block that lists all headings:
        </p>
        <pre><code class="javascript language-javascript">const visit = require('unist-util-visit');

function addDynamicBlock() {
  return (tree) =&gt; {
    const headings = [];

    // Collect all headings
    visit(tree, 'heading', (node) =&gt; {
      headings.push(node.children.map((child) =&gt; child.value).join(''));
    });

    // Create a summary block
    const summaryBlockNode = {
      type: 'paragraph',
      children: [
        {
          type: 'text',
          value: `📝 Summary of headings: ${headings.join(', ')}`,
        },
      ],
    };

    // Add the block at the end of the document
    tree.children.push(summaryBlockNode);
  };
}

module.exports = addDynamicBlock;</code></pre>
        <p>For this Markdown input:</p>
        <pre><code class="markdown language-markdown"># Introduction
## Features
## Installation</code></pre>
        <p>The output will include:</p>
        <pre><code class="markdown language-markdown"># Introduction

## Features

## Installation

📝 Summary of headings: Introduction, Features, Installation</code></pre>
        <hr />
        <h3 id="tips-for-block-manipulation">Tips for Block Manipulation</h3>
        <ol>
          <li>
            <strong>Node Types</strong>: Familiarize yourself with MDAST node
            types like <code>paragraph</code>, <code>html</code>,
            <code>code</code>, etc.
          </li>
          <li>
            <strong>Tree Location</strong>: Use traversal utilities like
            <code>unist-util-visit</code> to find the right location for
            inserting your block.
          </li>
          <li>
            <strong>Complex Blocks</strong>: Build more complex blocks by
            nesting nodes within <code>children</code>.
          </li>
        </ol>
        <hr />
        <p>
          Let me know if you want further assistance in building or extending
          the plugin! 🚀
        </p>
      </div>
      <div class="bubble user">
        what is the use for the blockAdded variable?
      </div>
      <div class="bubble">
        <p>
          The <code>blockAdded</code> variable in the code ensures that the
          block is added <strong>only once</strong>, even if multiple nodes
          match the condition (e.g., multiple headings in the document). Without
          this safeguard, the block would be added after every matched node,
          leading to unintended behavior.
        </p>
        <h3 id="why-is-blockadded-necessary">
          Why is <code>blockAdded</code> Necessary?
        </h3>
        <p>Let's break it down:</p>
        <ol>
          <li>
            <p>
              <strong>Traversal with <code>visit</code></strong
              >:
            </p>
            <ul>
              <li>
                The <code>visit</code> function recursively traverses all nodes
                of the specified type in the tree.
              </li>
              <li>
                If there are multiple nodes of the type being targeted (e.g.,
                multiple <code>heading</code> nodes), the callback will execute
                for each of them.
              </li>
            </ul>
          </li>
          <li>
            <p><strong>Use Case</strong>:</p>
            <ul>
              <li>
                The example intends to add a block
                <strong>only after the first heading</strong>. Therefore, we
                need to ensure the operation runs only once.
              </li>
            </ul>
          </li>
          <li>
            <p>
              <strong>How <code>blockAdded</code> Works</strong>:
            </p>
            <ul>
              <li>It starts as <code>false</code>.</li>
              <li>
                When the block is added (inside the callback), it’s set to
                <code>true</code>.
              </li>
              <li>
                Subsequent matches will skip the operation because the condition
                (<code>!blockAdded</code>) will evaluate to <code>false</code>.
              </li>
            </ul>
          </li>
        </ol>
        <h3 id="without-blockadded">Without <code>blockAdded</code></h3>
        <p>
          If you remove the <code>blockAdded</code> check, the block will be
          added after every heading in the document. For example:
        </p>
        <p>Input Markdown:</p>
        <pre><code class="markdown language-markdown"># Heading 1
## Heading 2
## Heading 3</code></pre>
        <p>
          Output <strong>without <code>blockAdded</code></strong
          >:
        </p>
        <pre><code class="markdown language-markdown"># Heading 1
📌 This block appears after the first heading.

## Heading 2
📌 This block appears after the first heading.

## Heading 3
📌 This block appears after the first heading.</code></pre>
        <p>
          Output <strong>with <code>blockAdded</code></strong
          >:
        </p>
        <pre><code class="markdown language-markdown"># Heading 1
📌 This block appears after the first heading.

## Heading 2
## Heading 3</code></pre>
        <hr />
        <h3 id="when-to-use-blockadded">
          When to Use <code>blockAdded</code>?
        </h3>
        <p>Use a similar variable when:</p>
        <ol>
          <li>
            You need to ensure an operation occurs only once during traversal.
          </li>
          <li>
            You are adding or modifying nodes based on conditions that could
            match multiple times.
          </li>
        </ol>
        <hr />
        <h3 id="alternative-approach-exiting-early">
          Alternative Approach: Exiting Early
        </h3>
        <p>
          In some cases, you can simplify the logic by "breaking out" of the
          traversal early. However, <code>unist-util-visit</code> does not
          support an explicit break. Instead, you can return a custom signal to
          indicate the traversal should stop, as shown below:
        </p>
        <pre><code class="javascript language-javascript">const visit = require('unist-util-visit-parents');

function addBlockAfterFirstHeading() {
  return (tree) =&gt; {
    visit(tree, 'heading', (node, index, parent) =&gt; {
      const customBlockNode = {
        type: 'paragraph',
        children: [
          {
            type: 'text',
            value: '📌 This block appears after the first heading.',
          },
        ],
      };

      parent.children.splice(index + 1, 0, customBlockNode); // Add the block
      return false; // Signal to stop traversal
    });
  };
}

module.exports = addBlockAfterFirstHeading;</code></pre>
        <p>
          This works similarly but stops further traversal after adding the
          block.
        </p>
        <hr />
        <h3 id="summary">Summary</h3>
        <ul>
          <li>
            <code>blockAdded</code> ensures the block is added only once by
            preventing further execution of the callback after the first match.
          </li>
          <li>
            It's a safeguard for plugins operating in situations where multiple
            nodes might trigger the same logic.
          </li>
          <li>
            Alternatives like stopping traversal early can sometimes simplify
            the code, depending on your needs.
          </li>
        </ul>
      </div>
      <div class="bubble user">
        is it possible to add a div with content inside of it?
      </div>
      <div class="bubble">
        <p>
          Yes, you can add a <code>div</code> with content inside it by creating
          a custom <strong>HTML block</strong> node. This is useful if you want
          to insert HTML content directly into your Markdown document.
        </p>
        <p>Here’s how you can achieve it:</p>
        <hr />
        <h3 id="example-adding-a-div-with-content">
          Example: Adding a <code>&lt;div&gt;</code> with Content
        </h3>
        <h4 id="plugin-code">Plugin Code:</h4>
        <pre><code class="javascript language-javascript">function addCustomDiv() {
  return (tree) =&gt; {
    const divNode = {
      type: 'html', // Specifies this is an HTML block
      value: '&lt;div class="custom-div"&gt;This is a custom div with content inside.&lt;/div&gt;',
    };

    // Add the custom div at the end of the document
    tree.children.push(divNode);
  };
}

module.exports = addCustomDiv;</code></pre>
        <h4 id="usage">Usage:</h4>
        <pre><code class="javascript language-javascript">const remark = require('remark');
const addCustomDiv = require('./addCustomDiv');

const markdown = `
# Heading 1
Some content here.
`;

remark()
  .use(addCustomDiv)
  .process(markdown, (err, file) =&gt; {
    if (err) throw err;
    console.log(String(file));
  });</code></pre>
        <h4 id="output">Output:</h4>
        <pre><code class="markdown language-markdown"># Heading 1
Some content here.

&lt;div class="custom-div"&gt;This is a custom div with content inside.&lt;/div&gt;</code></pre>
        <hr />
        <h3 id="adding-dynamic-content-inside-the-div">
          Adding Dynamic Content Inside the <code>&lt;div&gt;</code>
        </h3>
        <p>
          You can dynamically generate the content for the
          <code>&lt;div&gt;</code> by traversing the AST or passing data into
          your plugin. For example:
        </p>
        <h4 id="plugin-code-1">Plugin Code:</h4>
        <pre><code class="javascript language-javascript">const visit = require('unist-util-visit');

function addDivWithDynamicContent() {
  return (tree) =&gt; {
    let headingTexts = [];

    // Collect all heading text
    visit(tree, 'heading', (node) =&gt; {
      const text = node.children
        .filter((child) =&gt; child.type === 'text')
        .map((child) =&gt; child.value)
        .join(' ');
      headingTexts.push(text);
    });

    // Create the HTML div node
    const divNode = {
      type: 'html',
      value: `&lt;div class="custom-div"&gt;Headings: ${headingTexts.join(', ')}&lt;/div&gt;`,
    };

    // Add the custom div at the end of the document
    tree.children.push(divNode);
  };
}

module.exports = addDivWithDynamicContent;</code></pre>
        <h4 id="usage-1">Usage:</h4>
        <pre><code class="javascript language-javascript">const remark = require('remark');
const addDivWithDynamicContent = require('./addDivWithDynamicContent');

const markdown = `
# Introduction
## Features
## Installation
`;

remark()
  .use(addDivWithDynamicContent)
  .process(markdown, (err, file) =&gt; {
    if (err) throw err;
    console.log(String(file));
  });</code></pre>
        <h4 id="output-1">Output:</h4>
        <pre><code class="markdown language-markdown"># Introduction

## Features

## Installation

&lt;div class="custom-div"&gt;Headings: Introduction, Features, Installation&lt;/div&gt;</code></pre>
        <hr />
        <h3 id="adding-nested-content-inside-the-div">
          Adding Nested Content Inside the <code>&lt;div&gt;</code>
        </h3>
        <p>
          If you want to include nested Markdown or specific elements inside the
          <code>&lt;div&gt;</code>, you can generate Markdown or AST nodes and
          convert them to HTML.
        </p>
        <h4 id="plugin-code-2">Plugin Code:</h4>
        <pre><code class="javascript language-javascript">const visit = require('unist-util-visit');

function addNestedDiv() {
  return (tree) =&gt; {
    // Create nested content
    const nestedMarkdown = `
### Nested Content
This is content inside the custom div.
- Item 1
- Item 2
    `;

    // Process the nested Markdown into an AST
    const nestedAst = this.parse(nestedMarkdown);

    // Convert the nested AST to HTML
    const divContent = this.stringify(nestedAst);

    // Create the div node with nested content
    const divNode = {
      type: 'html',
      value: `&lt;div class="custom-div"&gt;${divContent}&lt;/div&gt;`,
    };

    // Add the div node at the end
    tree.children.push(divNode);
  };
}

module.exports = addNestedDiv;</code></pre>
        <h4 id="output-2">Output:</h4>
        <pre><code class="markdown language-markdown"># Heading

&lt;div class="custom-div"&gt;
&lt;h3&gt;Nested Content&lt;/h3&gt;
&lt;p&gt;This is content inside the custom div.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Item 1&lt;/li&gt;
&lt;li&gt;Item 2&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;</code></pre>
        <hr />
        <h3 id="summary">Summary</h3>
        <ul>
          <li>
            Use an <code>html</code> node for adding raw HTML, such as a
            <code>&lt;div&gt;</code>.
          </li>
          <li>
            Content inside the <code>&lt;div&gt;</code> can be static, dynamic,
            or even nested Markdown converted to HTML.
          </li>
          <li>
            For dynamic or nested content, traverse the AST or parse additional
            Markdown within your plugin.
          </li>
        </ul>
        <p>Let me know if you want help with a specific example! 🚀</p>
      </div>
      <div class="bubble user">
        what if the dynamic content of the div is going to be tree nodes
      </div>
      <div class="bubble">
        <p>
          If the dynamic content of the <code>&lt;div&gt;</code> is going to be
          <strong>tree nodes</strong> (i.e., AST nodes), you can embed those
          nodes as children of a custom parent node (e.g., a wrapper node
          representing a <code>div</code>). You don't need to directly use raw
          HTML; instead, you can structure the tree to represent the content.
        </p>
        <p>
          Here’s how you can create a <code>div</code> node and embed other AST
          nodes inside it:
        </p>
        <hr />
        <h3 id="1-adding-a-div-node-with-tree-nodes-as-content">
          1. <strong>Adding a Div Node with Tree Nodes as Content</strong>
        </h3>
        <p>
          You can create a custom <code>mdast</code>-like node for your
          <code>&lt;div&gt;</code> and append or insert other nodes as its
          children.
        </p>
        <h4 id="example-plugin">Example Plugin:</h4>
        <pre><code class="javascript language-javascript">const visit = require('unist-util-visit');

function wrapContentInDiv() {
  return (tree) =&gt; {
    // Create a custom "div" node
    const divNode = {
      type: 'div', // Custom type
      data: {
        hName: 'div', // Specify the HTML tag name for rendering
        hProperties: { className: 'custom-div' }, // Add class or other attributes
      },
      children: [], // Add tree nodes dynamically here
    };

    // Collect specific nodes to move into the div (e.g., all paragraphs)
    const nodesToWrap = [];
    visit(tree, 'paragraph', (node, index, parent) =&gt; {
      nodesToWrap.push({ node, index, parent });
    });

    // Remove the collected nodes from the tree and add them to the div
    nodesToWrap.forEach(({ node, index, parent }) =&gt; {
      parent.children.splice(index, 1); // Remove the node from its parent
      divNode.children.push(node); // Add the node to the div's children
    });

    // Add the div node at the end of the document
    tree.children.push(divNode);
  };
}

module.exports = wrapContentInDiv;</code></pre>
        <hr />
        <h3 id="2-rendering-the-custom-node">
          2. <strong>Rendering the Custom Node</strong>
        </h3>
        <p>
          Remark and related tools (like <code>remark-html</code>) will render
          the custom node as a <code>&lt;div&gt;</code> if you use the
          <code>data</code> properties (<code>hName</code> and
          <code>hProperties</code>) in the node.
        </p>
        <h4 id="output">Output:</h4>
        <p>Input Markdown:</p>
        <pre><code class="markdown language-markdown"># Heading

This is a paragraph.

Another paragraph.</code></pre>
        <p>Output:</p>
        <pre><code class="html language-html">&lt;h1&gt;Heading&lt;/h1&gt;
&lt;div class="custom-div"&gt;
  &lt;p&gt;This is a paragraph.&lt;/p&gt;
  &lt;p&gt;Another paragraph.&lt;/p&gt;
&lt;/div&gt;</code></pre>
        <hr />
        <h3 id="3-dynamic-content-as-nodes">
          3. <strong>Dynamic Content as Nodes</strong>
        </h3>
        <p>
          If the content inside the <code>&lt;div&gt;</code> is dynamically
          generated tree nodes (not just existing nodes), you can create and
          insert new nodes into the <code>children</code> of your custom
          <code>div</code> node.
        </p>
        <h4 id="example-generating-dynamic-content">
          Example: Generating Dynamic Content
        </h4>
        <pre><code class="javascript language-javascript">function addDynamicDivWithNodes() {
  return (tree) =&gt; {
    // Create the custom div node
    const divNode = {
      type: 'div',
      data: {
        hName: 'div',
        hProperties: { className: 'dynamic-div' },
      },
      children: [
        {
          type: 'heading',
          depth: 2,
          children: [{ type: 'text', value: 'Dynamic Heading' }],
        },
        {
          type: 'paragraph',
          children: [{ type: 'text', value: 'This content is dynamically generated.' }],
        },
      ],
    };

    // Add the div node to the end of the tree
    tree.children.push(divNode);
  };
}

module.exports = addDynamicDivWithNodes;</code></pre>
        <h4 id="output-1">Output:</h4>
        <p>Input Markdown:</p>
        <pre><code class="markdown language-markdown"># Title</code></pre>
        <p>Output:</p>
        <pre><code class="html language-html">&lt;h1&gt;Title&lt;/h1&gt;
&lt;div class="dynamic-div"&gt;
  &lt;h2&gt;Dynamic Heading&lt;/h2&gt;
  &lt;p&gt;This content is dynamically generated.&lt;/p&gt;
&lt;/div&gt;</code></pre>
        <hr />
        <h3 id="4-advanced-wrapping-nodes-in-div-based-on-conditions">
          4.
          <strong>Advanced: Wrapping Nodes in Div Based on Conditions</strong>
        </h3>
        <p>
          If you want to selectively wrap nodes based on conditions (e.g., wrap
          all <code>list</code> and <code>paragraph</code> nodes in a
          <code>&lt;div&gt;</code>), you can:
        </p>
        <h4 id="example-plugin-1">Example Plugin:</h4>
        <pre><code class="javascript language-javascript">const visit = require('unist-util-visit');

function wrapSpecificNodesInDiv() {
  return (tree) =&gt; {
    // Custom wrapper node
    const divNode = {
      type: 'div',
      data: {
        hName: 'div',
        hProperties: { className: 'custom-wrapper' },
      },
      children: [],
    };

    // Visit specific node types to wrap (e.g., paragraphs and lists)
    const nodesToWrap = [];
    visit(tree, (node) =&gt; {
      if (['paragraph', 'list'].includes(node.type)) {
        nodesToWrap.push(node);
      }
    });

    // Add the collected nodes to the div's children
    divNode.children.push(...nodesToWrap);

    // Filter out the wrapped nodes from the tree and add the div
    tree.children = tree.children.filter((node) =&gt; !nodesToWrap.includes(node));
    tree.children.push(divNode);
  };
}

module.exports = wrapSpecificNodesInDiv;</code></pre>
        <hr />
        <h3 id="5-key-notes">5. <strong>Key Notes</strong></h3>
        <ol>
          <li>
            <p><strong>Custom Node Types</strong>:</p>
            <ul>
              <li>
                <code>type: 'div'</code> is not an official
                <code>mdast</code> node, but you can use it with
                <code>data.hName</code> to define how it should render (e.g., as
                a <code>&lt;div&gt;</code>).
              </li>
              <li>
                Tools like <code>remark-html</code> or
                <code>rehype</code> respect <code>data.hName</code> and
                <code>data.hProperties</code>.
              </li>
            </ul>
          </li>
          <li>
            <p><strong>Dynamic Child Nodes</strong>:</p>
            <ul>
              <li>
                Dynamically generate new nodes and add them to the
                <code>children</code> array of your custom wrapper node.
              </li>
            </ul>
          </li>
          <li>
            <p><strong>Preserve Order</strong>:</p>
            <ul>
              <li>
                If you want to insert the <code>&lt;div&gt;</code> at a specific
                position in the tree, use the parent’s
                <code>children.splice</code> method.
              </li>
            </ul>
          </li>
        </ol>
        <hr />
        <p>
          Let me know if you'd like additional examples or a walkthrough for a
          specific use case! 🚀
        </p>
      </div>
      <div class="bubble user">where to find different node types?</div>
      <div class="bubble">
        <p>
          The different node types you can work with in
          <strong>Remark</strong> are defined by the
          <strong>MDAST specification</strong> (Markdown Abstract Syntax Tree).
          This specification is part of the
          <strong>syntax-tree</strong> ecosystem and provides a structured way
          to represent Markdown content as an AST.
        </p>
        <hr />
        <h3 id="1-primary-resource-mdast-specification">
          1. <strong>Primary Resource: MDAST Specification</strong>
        </h3>
        <p>
          The
          <a href="https://github.com/syntax-tree/mdast"
            >official MDAST documentation</a
          >
          is the best place to learn about node types. It provides detailed
          descriptions of:
        </p>
        <ul>
          <li>Node types</li>
          <li>Node properties</li>
          <li>Expected child nodes</li>
          <li>Usage examples</li>
        </ul>
        <hr />
        <h3 id="2-common-node-types">2. <strong>Common Node Types</strong></h3>
        <p>
          Here’s an overview of some commonly used node types and their
          structure:
        </p>
        <h4 id="root"><strong>Root</strong></h4>
        <ul>
          <li><strong>Type</strong>: <code>root</code></li>
          <li><strong>Description</strong>: Represents the entire document.</li>
          <li>
            <strong>Children</strong>: Other nodes like <code>heading</code>,
            <code>paragraph</code>, <code>list</code>, etc.
          </li>
        </ul>
        <pre><code class="json language-json">{
  "type": "root",
  "children": [...]
}</code></pre>
        <hr />
        <h4 id="heading"><strong>Heading</strong></h4>
        <ul>
          <li><strong>Type</strong>: <code>heading</code></li>
          <li>
            <strong>Description</strong>: Represents headings (<code>#</code>,
            <code>##</code>, etc.).
          </li>
          <li>
            <strong>Properties</strong>:
            <ul>
              <li>
                <code>depth</code>: Heading level (<code>1</code> for
                <code>#</code>, <code>2</code> for <code>##</code>, etc.).
              </li>
            </ul>
          </li>
          <li>
            <strong>Children</strong>: Inline nodes like <code>text</code> or
            <code>emphasis</code>.
          </li>
        </ul>
        <pre><code class="json language-json">{
  "type": "heading",
  "depth": 1,
  "children": [
    { "type": "text", "value": "Heading Text" }
  ]
}</code></pre>
        <hr />
        <h4 id="paragraph"><strong>Paragraph</strong></h4>
        <ul>
          <li><strong>Type</strong>: <code>paragraph</code></li>
          <li><strong>Description</strong>: Represents a block of text.</li>
          <li>
            <strong>Children</strong>: Inline nodes like <code>text</code>,
            <code>emphasis</code>, or <code>strong</code>.
          </li>
        </ul>
        <pre><code class="json language-json">{
  "type": "paragraph",
  "children": [
    { "type": "text", "value": "This is a paragraph." }
  ]
}</code></pre>
        <hr />
        <h4 id="text"><strong>Text</strong></h4>
        <ul>
          <li><strong>Type</strong>: <code>text</code></li>
          <li><strong>Description</strong>: Represents plain text.</li>
          <li>
            <strong>Properties</strong>:
            <ul>
              <li><code>value</code>: The text content.</li>
            </ul>
          </li>
        </ul>
        <pre><code class="json language-json">{
  "type": "text",
  "value": "Plain text"
}</code></pre>
        <hr />
        <h4 id="list"><strong>List</strong></h4>
        <ul>
          <li><strong>Type</strong>: <code>list</code></li>
          <li>
            <strong>Description</strong>: Represents a list (ordered or
            unordered).
          </li>
          <li>
            <strong>Properties</strong>:
            <ul>
              <li>
                <code>ordered</code>: <code>true</code> for ordered lists
                (<code>1.</code>, <code>2.</code>), <code>false</code> for
                unordered lists (<code>-</code>, <code>*</code>).
              </li>
              <li><code>start</code>: Starting number for ordered lists.</li>
            </ul>
          </li>
          <li><strong>Children</strong>: <code>listItem</code> nodes.</li>
        </ul>
        <pre><code class="json language-json">{
  "type": "list",
  "ordered": true,
  "children": [
    {
      "type": "listItem",
      "children": [
        { "type": "paragraph", "children": [{ "type": "text", "value": "Item 1" }] }
      ]
    }
  ]
}</code></pre>
        <hr />
        <h4 id="listitem"><strong>ListItem</strong></h4>
        <ul>
          <li><strong>Type</strong>: <code>listItem</code></li>
          <li><strong>Description</strong>: Represents a single list item.</li>
          <li>
            <strong>Children</strong>: Typically <code>paragraph</code> or
            <code>text</code> nodes.
          </li>
        </ul>
        <pre><code class="json language-json">{
  "type": "listItem",
  "children": [
    { "type": "paragraph", "children": [{ "type": "text", "value": "Item 1" }] }
  ]
}</code></pre>
        <hr />
        <h4 id="blockquote"><strong>Blockquote</strong></h4>
        <ul>
          <li><strong>Type</strong>: <code>blockquote</code></li>
          <li>
            <strong>Description</strong>: Represents a blockquote
            (<code>&gt;</code>).
          </li>
          <li>
            <strong>Children</strong>: Typically <code>paragraph</code> nodes.
          </li>
        </ul>
        <pre><code class="json language-json">{
  "type": "blockquote",
  "children": [
    { "type": "paragraph", "children": [{ "type": "text", "value": "Quoted text." }] }
  ]
}</code></pre>
        <hr />
        <h4 id="code"><strong>Code</strong></h4>
        <ul>
          <li><strong>Type</strong>: <code>code</code></li>
          <li><strong>Description</strong>: Represents a block of code.</li>
          <li>
            <strong>Properties</strong>:
            <ul>
              <li>
                <code>lang</code>: Language of the code block (e.g.,
                <code>javascript</code>).
              </li>
              <li><code>value</code>: Code content.</li>
            </ul>
          </li>
        </ul>
        <pre><code class="json language-json">{
  "type": "code",
  "lang": "javascript",
  "value": "console.log('Hello, world!');"
}</code></pre>
        <hr />
        <h4 id="inlinecode"><strong>InlineCode</strong></h4>
        <ul>
          <li><strong>Type</strong>: <code>inlineCode</code></li>
          <li><strong>Description</strong>: Represents inline code.</li>
          <li>
            <strong>Properties</strong>:
            <ul>
              <li><code>value</code>: Code content.</li>
            </ul>
          </li>
        </ul>
        <pre><code class="json language-json">{
  "type": "inlineCode",
  "value": "const x = 10;"
}</code></pre>
        <hr />
        <h4 id="thematicbreak"><strong>ThematicBreak</strong></h4>
        <ul>
          <li><strong>Type</strong>: <code>thematicBreak</code></li>
          <li>
            <strong>Description</strong>: Represents a horizontal rule (<code
              >---</code
            >
            or <code>***</code>).
          </li>
        </ul>
        <pre><code class="json language-json">{
  "type": "thematicBreak"
}</code></pre>
        <hr />
        <h4 id="link"><strong>Link</strong></h4>
        <ul>
          <li><strong>Type</strong>: <code>link</code></li>
          <li><strong>Description</strong>: Represents a hyperlink.</li>
          <li>
            <strong>Properties</strong>:
            <ul>
              <li><code>url</code>: The hyperlink URL.</li>
              <li><code>title</code>: Optional title for the link.</li>
            </ul>
          </li>
          <li>
            <strong>Children</strong>: Inline nodes like <code>text</code>.
          </li>
        </ul>
        <pre><code class="json language-json">{
  "type": "link",
  "url": "https://example.com",
  "title": "Example",
  "children": [
    { "type": "text", "value": "Click here" }
  ]
}</code></pre>
        <hr />
        <h4 id="image"><strong>Image</strong></h4>
        <ul>
          <li><strong>Type</strong>: <code>image</code></li>
          <li><strong>Description</strong>: Represents an image.</li>
          <li>
            <strong>Properties</strong>:
            <ul>
              <li><code>url</code>: Image URL.</li>
              <li><code>alt</code>: Alternative text.</li>
              <li><code>title</code>: Optional title.</li>
            </ul>
          </li>
        </ul>
        <pre><code class="json language-json">{
  "type": "image",
  "url": "https://example.com/image.png",
  "alt": "An example image",
  "title": "Example Image"
}</code></pre>
        <hr />
        <h3 id="3-find-node-types-programmatically">
          3. <strong>Find Node Types Programmatically</strong>
        </h3>
        <p>
          You can inspect the structure of the AST for a specific Markdown file
          to see all available node types:
        </p>
        <h4 id="example">Example:</h4>
        <pre><code class="javascript language-javascript">const remark = require('remark');

const markdown = `
# Heading

This is a paragraph.

- List item 1
- List item 2

&gt; Blockquote
`;

remark().parse(markdown, (err, tree) =&gt; {
  if (err) throw err;
  console.log(JSON.stringify(tree, null, 2)); // View the AST
});</code></pre>
        <p>The output will include all node types and their structure.</p>
        <hr />
        <h3 id="4-custom-node-types">4. <strong>Custom Node Types</strong></h3>
        <p>
          You can also create custom nodes with a <code>type</code> of your
          choice. Just ensure you handle rendering appropriately using tools
          like <code>remark-html</code> or <code>rehype</code>.
        </p>
        <hr />
        <h3 id="5-tools-and-utilities">
          5. <strong>Tools and Utilities</strong>
        </h3>
        <ul>
          <li>
            <strong
              ><a href="https://github.com/syntax-tree/unist-util-visit"
                >unist-util-visit</a
              ></strong
            >: Traverse and filter nodes by type.
          </li>
          <li>
            <strong
              ><a href="https://github.com/syntax-tree/unist-util-inspect"
                >unist-util-inspect</a
              ></strong
            >: Pretty-print the AST for better understanding.
          </li>
        </ul>
        <hr />
        <p>
          Let me know if you'd like more detailed help with a specific type! 🚀
        </p>
      </div>
      <div class="bubble user">
        How to insert a link instead of a paragraph?
      </div>
      <div class="bubble">
        <p>
          To replace a <code>paragraph</code> node with a <code>link</code> node
          in the AST using a <strong>Remark plugin</strong>, you need to:
        </p>
        <ol>
          <li>Traverse the AST to find the <code>paragraph</code> nodes.</li>
          <li>
            Replace the <code>paragraph</code> node with a
            <code>link</code> node.
          </li>
        </ol>
        <p>Here's how you can do it step by step:</p>
        <hr />
        <h3 id="1-plugin-to-replace-paragraph-with-a-link">
          1. <strong>Plugin to Replace Paragraph with a Link</strong>
        </h3>
        <p>
          Below is an example plugin that replaces all
          <code>paragraph</code> nodes with a <code>link</code> node:
        </p>
        <pre><code class="javascript language-javascript">const visit = require('unist-util-visit');

function replaceParagraphWithLink() {
  return (tree) =&gt; {
    visit(tree, 'paragraph', (node, index, parent) =&gt; {
      // Replace the paragraph with a link node
      const linkNode = {
        type: 'link',
        url: 'https://example.com',
        title: 'Example Site',
        children: [
          {
            type: 'text',
            value: 'Click here to visit Example.com!',
          },
        ],
      };

      // Replace the paragraph node with the link node
      parent.children[index] = linkNode;
    });
  };
}

module.exports = replaceParagraphWithLink;</code></pre>
        <hr />
        <h3 id="2-explanation-of-the-code">
          2. <strong>Explanation of the Code</strong>
        </h3>
        <ol>
          <li>
            <p><strong>Traversal</strong>:</p>
            <ul>
              <li>
                The <code>visit</code> function traverses the AST to find nodes
                of type <code>paragraph</code>.
              </li>
            </ul>
          </li>
          <li>
            <p>
              <strong>Creating a <code>link</code> Node</strong>:
            </p>
            <ul>
              <li>
                The <code>link</code> node has:
                <ul>
                  <li><code>type</code>: <code>"link"</code></li>
                  <li>
                    <code>url</code>: The destination URL (e.g.,
                    <code>https://example.com</code>).
                  </li>
                  <li><code>title</code>: Optional title for the link.</li>
                  <li>
                    <code>children</code>: An array of inline nodes, like
                    <code>text</code>, which represents the visible link text.
                  </li>
                </ul>
              </li>
            </ul>
          </li>
          <li>
            <p><strong>Replacing the Node</strong>:</p>
            <ul>
              <li>
                <code>parent.children[index]</code> replaces the
                <code>paragraph</code> node with the newly created
                <code>link</code> node.
              </li>
            </ul>
          </li>
        </ol>
        <hr />
        <h3 id="3-usage">3. <strong>Usage</strong></h3>
        <h4 id="input-markdown">Input Markdown:</h4>
        <pre><code class="markdown language-markdown">This is a paragraph.

Another paragraph.</code></pre>
        <h4 id="plugin-application">Plugin Application:</h4>
        <pre><code class="javascript language-javascript">const remark = require('remark');
const replaceParagraphWithLink = require('./replaceParagraphWithLink');

const markdown = `
This is a paragraph.

Another paragraph.
`;

remark()
  .use(replaceParagraphWithLink)
  .process(markdown, (err, file) =&gt; {
    if (err) throw err;
    console.log(String(file));
  });</code></pre>
        <h4 id="output-markdown">Output Markdown:</h4>
        <pre><code class="markdown language-markdown">[Click here to visit Example.com!](https://example.com)

[Click here to visit Example.com!](https://example.com)</code></pre>
        <hr />
        <h3 id="4-conditional-replacement">
          4. <strong>Conditional Replacement</strong>
        </h3>
        <p>
          You can apply conditions to replace only certain paragraphs. For
          example, replace a paragraph only if it contains specific text:
        </p>
        <pre><code class="javascript language-javascript">function replaceSpecificParagraphWithLink() {
  return (tree) =&gt; {
    visit(tree, 'paragraph', (node, index, parent) =&gt; {
      const paragraphText = node.children
        .filter((child) =&gt; child.type === 'text')
        .map((child) =&gt; child.value)
        .join('');

      if (paragraphText.includes('Replace me')) {
        const linkNode = {
          type: 'link',
          url: 'https://example.com',
          title: 'Example Site',
          children: [
            {
              type: 'text',
              value: 'Click here to visit Example.com!',
            },
          ],
        };

        parent.children[index] = linkNode;
      }
    });
  };
}</code></pre>
        <hr />
        <h3 id="5-output-as-html">5. <strong>Output as HTML</strong></h3>
        <p>
          If you process the Markdown to HTML using <code>remark-html</code>,
          the link node will render as an HTML <code>&lt;a&gt;</code> tag.
        </p>
        <h4 id="example">Example:</h4>
        <pre><code class="javascript language-javascript">const html = require('remark-html');

remark()
  .use(replaceParagraphWithLink)
  .use(html)
  .process(markdown, (err, file) =&gt; {
    if (err) throw err;
    console.log(String(file)); // Outputs the HTML
  });</code></pre>
        <h4 id="output-html">Output HTML:</h4>
        <pre><code class="html language-html">&lt;a href="https://example.com" title="Example Site"&gt;Click here to visit Example.com!&lt;/a&gt;

&lt;a href="https://example.com" title="Example Site"&gt;Click here to visit Example.com!&lt;/a&gt;</code></pre>
        <hr />
        <h3 id="key-notes">Key Notes:</h3>
        <ol>
          <li>
            <p><strong>Node Types</strong>:</p>
            <ul>
              <li>Use the <code>type: 'link'</code> for links in the AST.</li>
              <li>
                Links should have <code>children</code> to define the link text.
              </li>
            </ul>
          </li>
          <li>
            <p><strong>Replace or Insert</strong>:</p>
            <ul>
              <li>
                <code>parent.children[index] = ...</code> replaces a node.
              </li>
              <li>
                To add instead of replace, use
                <code>parent.children.splice(index, 0, newNode)</code>.
              </li>
            </ul>
          </li>
          <li>
            <p><strong>Selective Replacement</strong>:</p>
            <ul>
              <li>
                Use conditions like <code>if</code> to replace specific nodes.
              </li>
            </ul>
          </li>
        </ol>
        <p>Let me know if you need further clarifications or adjustments! 🚀</p>
      </div>
      <div class="bubble user">
        How to insert something at the beginning of the tree?
      </div>
      <div class="bubble">
        <p>
          To insert a new node at the beginning of the tree in Remark, you
          modify the <code>children</code> array of the root node. The
          <code>children</code> array represents all top-level nodes in the
          document, so inserting at the beginning involves prepending the new
          node.
        </p>
        <p>Here’s how you can do it:</p>
        <hr />
        <h3 id="example-1-insert-a-paragraph-node-at-the-beginning">
          Example 1: Insert a Paragraph Node at the Beginning
        </h3>
        <p>
          This example inserts a <code>paragraph</code> node at the start of the
          Markdown document:
        </p>
        <h4 id="plugin-code">Plugin Code:</h4>
        <pre><code class="javascript language-javascript">function insertAtBeginning() {
  return (tree) =&gt; {
    const newNode = {
      type: 'paragraph',
      children: [
        {
          type: 'text',
          value: 'This is a custom paragraph inserted at the beginning.',
        },
      ],
    };

    // Insert the new node at the beginning of the tree
    tree.children.unshift(newNode);
  };
}

module.exports = insertAtBeginning;</code></pre>
        <h4 id="usage">Usage:</h4>
        <pre><code class="javascript language-javascript">const remark = require('remark');
const insertAtBeginning = require('./insertAtBeginning');

const markdown = `
# Heading

This is the original content.
`;

remark()
  .use(insertAtBeginning)
  .process(markdown, (err, file) =&gt; {
    if (err) throw err;
    console.log(String(file));
  });</code></pre>
        <h4 id="output-markdown">Output Markdown:</h4>
        <pre><code class="markdown language-markdown">This is a custom paragraph inserted at the beginning.

# Heading

This is the original content.</code></pre>
        <hr />
        <h3 id="example-2-insert-a-link-node-at-the-beginning">
          Example 2: Insert a Link Node at the Beginning
        </h3>
        <p>
          To insert a <code>link</code> node at the beginning, create the
          <code>link</code> node structure and prepend it to the
          <code>children</code> array:
        </p>
        <h4 id="plugin-code-1">Plugin Code:</h4>
        <pre><code class="javascript language-javascript">function insertLinkAtBeginning() {
  return (tree) =&gt; {
    const linkNode = {
      type: 'link',
      url: 'https://example.com',
      title: 'Example Site',
      children: [
        {
          type: 'text',
          value: 'Visit Example.com',
        },
      ],
    };

    // Insert the link node at the beginning of the tree
    tree.children.unshift(linkNode);
  };
}

module.exports = insertLinkAtBeginning;</code></pre>
        <h4 id="output-markdown-1">Output Markdown:</h4>
        <pre><code class="markdown language-markdown">[Visit Example.com](https://example.com)

# Heading

This is the original content.</code></pre>
        <hr />
        <h3 id="example-3-insert-an-html-block-at-the-beginning">
          Example 3: Insert an HTML Block at the Beginning
        </h3>
        <p>
          If you want to insert raw HTML (e.g., a custom
          <code>&lt;div&gt;</code>), use an <code>html</code> node:
        </p>
        <h4 id="plugin-code-2">Plugin Code:</h4>
        <pre><code class="javascript language-javascript">function insertHtmlAtBeginning() {
  return (tree) =&gt; {
    const htmlNode = {
      type: 'html',
      value: '&lt;div class="intro"&gt;Welcome to the document!&lt;/div&gt;',
    };

    // Insert the HTML block at the beginning
    tree.children.unshift(htmlNode);
  };
}

module.exports = insertHtmlAtBeginning;</code></pre>
        <h4 id="output-markdown-2">Output Markdown:</h4>
        <pre><code class="markdown language-markdown">&lt;div class="intro"&gt;Welcome to the document!&lt;/div&gt;

# Heading

This is the original content.</code></pre>
        <hr />
        <h3 id="example-4-insert-a-custom-node-at-the-beginning">
          Example 4: Insert a Custom Node at the Beginning
        </h3>
        <p>
          If you want to insert a custom node (e.g., a
          <code>blockquote</code> or a dynamic node), follow this approach:
        </p>
        <h4 id="plugin-code-3">Plugin Code:</h4>
        <pre><code class="javascript language-javascript">function insertDynamicNodeAtBeginning() {
  return (tree) =&gt; {
    const blockquoteNode = {
      type: 'blockquote',
      children: [
        {
          type: 'paragraph',
          children: [
            { type: 'text', value: 'This is a blockquote inserted dynamically.' },
          ],
        },
      ],
    };

    // Insert the blockquote node at the beginning
    tree.children.unshift(blockquoteNode);
  };
}

module.exports = insertDynamicNodeAtBeginning;</code></pre>
        <h4 id="output-markdown-3">Output Markdown:</h4>
        <pre><code class="markdown language-markdown">&gt; This is a blockquote inserted dynamically.

# Heading

This is the original content.</code></pre>
        <hr />
        <h3 id="key-points">Key Points</h3>
        <ol>
          <li>
            <p>
              <strong>Use <code>unshift</code></strong
              >:
            </p>
            <ul>
              <li>
                The <code>unshift</code> method adds the new node at the start
                of the <code>children</code> array.
              </li>
            </ul>
          </li>
          <li>
            <p><strong>Node Structure</strong>:</p>
            <ul>
              <li>
                Ensure the inserted node follows the
                <strong>MDAST specification</strong> for its type.
              </li>
            </ul>
          </li>
          <li>
            <p><strong>Node Types</strong>:</p>
            <ul>
              <li>
                Common types for insertion:
                <ul>
                  <li><code>paragraph</code></li>
                  <li><code>link</code></li>
                  <li><code>html</code></li>
                  <li><code>blockquote</code></li>
                </ul>
              </li>
            </ul>
          </li>
          <li>
            <p><strong>Dynamic Content</strong>:</p>
            <ul>
              <li>
                Generate dynamic nodes (e.g., headings or lists) by creating
                appropriate child structures.
              </li>
            </ul>
          </li>
          <li>
            <p><strong>Order Preservation</strong>:</p>
            <ul>
              <li>
                Inserting at the beginning doesn’t disrupt the order of other
                nodes.
              </li>
            </ul>
          </li>
        </ol>
        <p>
          Let me know if you need further assistance with this or related
          transformations! 🚀
        </p>
      </div>
      <div class="bubble user">
        what is the proper type for the tree parameter?
      </div>
      <div class="bubble">
        <p>
          The proper type for the <code>tree</code> parameter in a
          <strong>Remark</strong> plugin is typically the root node of an
          <strong>MDAST</strong> (Markdown Abstract Syntax Tree). This root node
          represents the entire Markdown document, and its type is
          <code>Root</code>.
        </p>
        <p>
          If you’re working in a TypeScript project or want to explicitly type
          it, you can use the <code>Root</code> type from the
          <code>@types/mdast</code> package or define it yourself.
        </p>
        <hr />
        <h3 id="1-using-typesmdast">
          1. <strong>Using <code>@types/mdast</code></strong>
        </h3>
        <p>
          The <code>@types/mdast</code> package provides type definitions for
          the MDAST structure, including <code>Root</code> and other node types.
        </p>
        <h4 id="install-the-type-definitions">Install the Type Definitions</h4>
        <pre><code class="bash language-bash">npm install @types/mdast</code></pre>
        <h4 id="import-and-use-the-root-type">
          Import and Use the <code>Root</code> Type
        </h4>
        <pre><code class="typescript language-typescript">import { Root } from 'mdast';

function myRemarkPlugin() {
  return (tree: Root) =&gt; {
    // Work with the tree
    console.log(tree.type); // Logs "root"
  };
}</code></pre>
        <hr />
        <h3 id="2-manually-typing-the-tree-parameter">
          2. <strong>Manually Typing the Tree Parameter</strong>
        </h3>
        <p>
          If you’re not using <code>@types/mdast</code>, you can define a basic
          type for the <code>Root</code> node and extend it as needed.
        </p>
        <h4 id="basic-root-type">Basic <code>Root</code> Type</h4>
        <pre><code class="typescript language-typescript">type Root = {
  type: 'root';
  children: Node[];
};

type Node = {
  type: string;
  [key: string]: any; // Allow additional properties
};</code></pre>
        <h4 id="plugin-example">Plugin Example</h4>
        <pre><code class="typescript language-typescript">function myRemarkPlugin() {
  return (tree: Root) =&gt; {
    tree.children.forEach((node) =&gt; {
      console.log(node.type);
    });
  };
}</code></pre>
        <hr />
        <h3 id="3-using-unist-types">
          3. <strong>Using <code>unist</code> Types</strong>
        </h3>
        <p>
          Since MDAST is part of the <strong>unist</strong> syntax tree
          ecosystem, you can use types from the
          <code>@types/unist</code> package for generic AST typing.
        </p>
        <h4 id="install-typesunist">Install <code>@types/unist</code></h4>
        <pre><code class="bash language-bash">npm install @types/unist</code></pre>
        <h4 id="use-unist-types">Use <code>unist</code> Types</h4>
        <pre><code class="typescript language-typescript">import { Node } from 'unist';

function myRemarkPlugin() {
  return (tree: Node) =&gt; {
    if (tree.type === 'root') {
      console.log('This is the root node.');
    }
  };
}</code></pre>
        <hr />
        <h3 id="4-unified-type-system-recommended">
          4. <strong>Unified Type System (Recommended)</strong>
        </h3>
        <p>
          If you use the <strong>unified</strong> framework (which Remark is
          part of), you can install and use <code>@types/unified</code> for a
          more complete typing system.
        </p>
        <h4 id="install-unified-types">Install Unified Types</h4>
        <pre><code class="bash language-bash">npm install @types/unified</code></pre>
        <h4 id="type-the-plugin">Type the Plugin</h4>
        <pre><code class="typescript language-typescript">import { Plugin } from 'unified';
import { Root } from 'mdast';

const myRemarkPlugin: Plugin&lt;[], Root&gt; = () =&gt; {
  return (tree) =&gt; {
    console.log('Root node type:', tree.type);
  };
};</code></pre>
        <hr />
        <h3 id="summary-of-types">Summary of Types</h3>
        <ul>
          <li><strong>Root Type</strong>:</li>
        </ul>
        <pre><code class="typescript language-typescript">  type Root = {
    type: 'root';
    children: Node[];
  };</code></pre>
        <ul>
          <li><strong>Node Type</strong>:</li>
        </ul>
        <pre><code class="typescript language-typescript">  type Node = {
    type: string;
    children?: Node[];
    [key: string]: any;
  };</code></pre>
        <ul>
          <li>
            <strong>Recommended Types</strong>:<br />
            Use <code>Root</code> and <code>Node</code> from
            <code>@types/mdast</code> or <code>@types/unist</code>.
          </li>
        </ul>
        <p>
          Let me know if you want more detailed examples or explanations for any
          of these! 🚀
        </p>
      </div>
      <div class="bubble user">give me the type from unist</div>
      <div class="bubble">
        <p>
          The type from <strong>unist</strong> that represents a generic
          Abstract Syntax Tree (AST) node is <code>Node</code>. If you're
          working with <strong>unist</strong>, you can use the
          <code>Node</code> interface and its extensions for more specific
          types.
        </p>
        <p>Here’s a breakdown of the relevant types:</p>
        <hr />
        <h3 id="1-node-type">
          1. <strong><code>Node</code> Type</strong>
        </h3>
        <p>
          The <code>Node</code> type from <code>unist</code> serves as the base
          type for all nodes in a syntax tree:
        </p>
        <pre><code class="typescript language-typescript">import { Node } from 'unist';

interface Node {
  type: string; // The type of the node (e.g., "root", "paragraph", "heading")
  data?: unknown; // Optional metadata about the node
  position?: Position; // Optional positional info in the source document
}</code></pre>
        <ul>
          <li>
            <strong>Properties</strong>:
            <ul>
              <li>
                <code>type</code>: A string representing the type of the node
                (e.g., <code>'root'</code>, <code>'paragraph'</code>, etc.).
              </li>
              <li>
                <code>data</code>: Optional metadata associated with the node
                (e.g., custom attributes).
              </li>
              <li>
                <code>position</code>: Optional <code>Position</code> object
                indicating where the node is located in the source Markdown.
              </li>
            </ul>
          </li>
        </ul>
        <hr />
        <h3 id="2-parent-type">
          2. <strong><code>Parent</code> Type</strong>
        </h3>
        <p>
          For nodes that can contain child nodes (like <code>root</code>,
          <code>paragraph</code>, or <code>heading</code>), the
          <code>Parent</code> type extends <code>Node</code> with the
          <code>children</code> property.
        </p>
        <pre><code class="typescript language-typescript">import { Node } from 'unist';

interface Parent extends Node {
  children: Node[]; // Array of child nodes
}</code></pre>
        <hr />
        <h3 id="3-literal-type">
          3. <strong><code>Literal</code> Type</strong>
        </h3>
        <p>
          For nodes that contain a value (e.g., text nodes or code blocks), the
          <code>Literal</code> type extends <code>Node</code> with a
          <code>value</code> property.
        </p>
        <pre><code class="typescript language-typescript">import { Node } from 'unist';

interface Literal extends Node {
  value: unknown; // The content of the node (e.g., text content)
}</code></pre>
        <hr />
        <h3 id="4-position-and-point-types">
          4. <strong><code>Position</code> and <code>Point</code> Types</strong>
        </h3>
        <p>
          The <code>Position</code> and <code>Point</code> types describe the
          location of a node in the source Markdown:
        </p>
        <pre><code class="typescript language-typescript">interface Position {
  start: Point; // Start of the node
  end: Point;   // End of the node
  indent?: number[]; // Optional indentation info
}

interface Point {
  line: number; // Line number
  column: number; // Column number
  offset?: number; // Optional character offset in the document
}</code></pre>
        <hr />
        <h3 id="5-example-root-type">
          5. <strong>Example: <code>Root</code> Type</strong>
        </h3>
        <p>
          The <code>Root</code> node is a common entry point in MDAST (used for
          the entire document). It extends <code>Parent</code> since it contains
          child nodes.
        </p>
        <pre><code class="typescript language-typescript">import { Parent } from 'unist';

interface Root extends Parent {
  type: 'root';
}</code></pre>
        <hr />
        <h3 id="6-using-the-types-in-a-plugin">
          6. <strong>Using the Types in a Plugin</strong>
        </h3>
        <p>
          When writing a <strong>Remark</strong> plugin, the
          <code>tree</code> parameter can be typed as a <code>Node</code> or,
          more specifically, as a <code>Root</code> node if you're working at
          the document level:
        </p>
        <pre><code class="typescript language-typescript">import { Node, Parent, Root } from 'unist';

function myPlugin() {
  return (tree: Root) =&gt; {
    console.log(tree.type); // Logs "root"

    tree.children.forEach((node: Node) =&gt; {
      console.log(node.type); // Logs types of child nodes (e.g., "paragraph")
    });
  };
}</code></pre>
        <hr />
        <h3 id="7-install-unist-type-definitions">
          7. <strong>Install <code>unist</code> Type Definitions</strong>
        </h3>
        <p>
          To use these types in your project, install the
          <code>@types/unist</code> package:
        </p>
        <pre><code class="bash language-bash">npm install @types/unist</code></pre>
        <hr />
        <h3 id="summary-of-core-types">Summary of Core Types</h3>
        <table>
          <thead>
            <tr>
              <th id="**type**"><strong>Type</strong></th>
              <th id="**description**"><strong>Description</strong></th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td><code>Node</code></td>
              <td>
                Base type for all syntax tree nodes (<code>type</code>,
                <code>data</code>, <code>position</code>).
              </td>
            </tr>
            <tr>
              <td><code>Parent</code></td>
              <td>
                Extends <code>Node</code>, includes a
                <code>children</code> array (used for <code>root</code>,
                <code>paragraph</code>, <code>heading</code>, etc.).
              </td>
            </tr>
            <tr>
              <td><code>Literal</code></td>
              <td>
                Extends <code>Node</code>, includes a
                <code>value</code> property (used for <code>text</code>,
                <code>code</code>, etc.).
              </td>
            </tr>
            <tr>
              <td><code>Position</code></td>
              <td>
                Represents the position of a node in the source Markdown
                (<code>start</code>, <code>end</code>, <code>indent</code>).
              </td>
            </tr>
            <tr>
              <td><code>Root</code></td>
              <td>
                A specific <code>Parent</code> node representing the entire
                document, with <code>type: 'root'</code>.
              </td>
            </tr>
          </tbody>
        </table>
        <p>
          Let me know if you need more details or examples for specific nodes!
          🚀
        </p>
      </div>
      <div class="bubble user">
        add typescript types to this for me import type { Node } from 'unist';
        import { visit } from 'unist-util-visit'; const toc = {}; export const
        remarkToc = () =&gt; { return (tree: Node) =&gt; { visit(tree,
        'heading', (node, index, parent) =&gt; { const divNode = { type: 'div',
        data: { hName: 'div', hProperties: { className: 'dynamic-div' }, },
        children: [ { type: 'link', url: '#test', children: [{ type: 'text',
        value: 'This content is dynamically generated.' }], }, ], };
        console.log('here'); // Add the div node to the end of the tree
        tree.children.push(divNode); }); }; };
      </div>
      <div class="bubble">
        <p>
          Here’s the updated code with proper
          <strong>TypeScript types</strong> applied. I've added typings to the
          <code>tree</code>, <code>node</code>, and other variables, leveraging
          the <code>unist</code> and <code>mdast</code> type definitions.
        </p>
        <hr />
        <h3 id="updated-code">Updated Code</h3>
        <pre><code class="typescript language-typescript">import type { Node, Parent } from 'unist'; // Import types for Node and Parent
import type { Heading, Link, Text } from 'mdast'; // Import specific node types from mdast
import { visit } from 'unist-util-visit';

const toc: Record&lt;string, unknown&gt; = {}; // Add a type for `toc` if needed

export const remarkToc = () =&gt; {
  return (tree: Parent) =&gt; {
    // Ensure the tree is a Parent node (it has `children`)
    visit(tree, 'heading', (node: Heading, index: number | null, parent: Parent | null) =&gt; {
      // Define the div node with proper types
      const divNode: Parent = {
        type: 'div', // Custom node type
        data: {
          hName: 'div', // Rendered as &lt;div&gt; in HTML
          hProperties: { className: 'dynamic-div' }, // Add attributes
        },
        children: [
          {
            type: 'link', // Link node
            url: '#test', // Target URL
            children: [
              {
                type: 'text', // Text node
                value: 'This content is dynamically generated.', // Text content
              } as Text, // Explicit type for text node
            ],
          } as Link, // Explicit type for link node
        ],
      };

      console.log('here');

      // Add the div node to the end of the tree
      (tree as Parent).children.push(divNode); // Cast `tree` to Parent to access `children`
    });
  };
};</code></pre>
        <hr />
        <h3 id="key-updates-and-explanation">Key Updates and Explanation</h3>
        <ol>
          <li>
            <p>
              <strong
                ><code>Node</code> and <code>Parent</code> from
                <code>unist</code></strong
              >:
            </p>
            <ul>
              <li><code>Node</code>: The base type for all AST nodes.</li>
              <li>
                <code>Parent</code>: Extends <code>Node</code>, adding the
                <code>children</code> property (used for nodes like
                <code>root</code>, <code>heading</code>, and
                <code>paragraph</code>).
              </li>
            </ul>
          </li>
          <li>
            <p>
              <strong>Specific Types from <code>mdast</code></strong
              >:
            </p>
            <ul>
              <li>
                <code>Heading</code>: Represents a Markdown heading
                (<code>#</code>, <code>##</code>, etc.).
              </li>
              <li>
                <code>Link</code>: Represents a link <code>[text](url)</code>.
              </li>
              <li><code>Text</code>: Represents plain text within the AST.</li>
            </ul>
          </li>
          <li>
            <p><strong>Types for Callback Parameters</strong>:</p>
            <ul>
              <li>
                <code>node</code>: Typed as <code>Heading</code> since the
                <code>visit</code> function is targeting
                <code>heading</code> nodes.
              </li>
              <li>
                <code>index</code>: A <code>number</code> or <code>null</code>,
                representing the position of the node in its parent's
                <code>children</code> array.
              </li>
              <li>
                <code>parent</code>: A <code>Parent</code> node or
                <code>null</code> (if the node has no parent).
              </li>
            </ul>
          </li>
          <li>
            <p><strong>Custom Node (<code>divNode</code>)</strong>:</p>
            <ul>
              <li>
                Defined as a <code>Parent</code> node, with custom
                <code>data</code> to ensure compatibility with
                <code>remark-html</code> or other plugins that handle HTML
                attributes.
              </li>
            </ul>
          </li>
          <li>
            <p>
              <strong><code>toc</code> Type</strong>:
            </p>
            <ul>
              <li>
                Used <code>Record&lt;string, unknown&gt;</code> as a
                placeholder. Replace with a more specific type if necessary.
              </li>
            </ul>
          </li>
        </ol>
        <hr />
        <h3 id="dependencies">Dependencies</h3>
        <p>
          To use these types, ensure you have the following type definitions
          installed:
        </p>
        <pre><code class="bash language-bash">npm install @types/unist @types/mdast</code></pre>
        <hr />
        <h3 id="example-tree-modification">Example Tree Modification</h3>
        <p>Input Markdown:</p>
        <pre><code class="markdown language-markdown"># Heading</code></pre>
        <p>Generated Tree:</p>
        <pre><code class="json language-json">{
  "type": "root",
  "children": [
    {
      "type": "heading",
      "depth": 1,
      "children": [
        {
          "type": "text",
          "value": "Heading"
        }
      ]
    },
    {
      "type": "div",
      "data": {
        "hName": "div",
        "hProperties": {
          "className": "dynamic-div"
        }
      },
      "children": [
        {
          "type": "link",
          "url": "#test",
          "children": [
            {
              "type": "text",
              "value": "This content is dynamically generated."
            }
          ]
        }
      ]
    }
  ]
}</code></pre>
        <hr />
        <p>Let me know if you need further adjustments or explanations! 🚀</p>
      </div>
      <div class="bubble user">How to add a style object to the link?</div>
      <div class="bubble">
        <p>
          To add a <code>style</code> object to the <code>link</code> in the
          AST, you can include it in the <code>data</code> property of the
          <code>link</code> node under <code>hProperties</code>. The
          <code>data</code> property allows you to specify custom attributes
          that will be used when rendering the AST, for example, by
          <strong>remark-html</strong> or other compatible plugins.
        </p>
        <p>
          Here’s how you can add a <code>style</code> object to the
          <code>link</code>:
        </p>
        <hr />
        <h3 id="updated-code-adding-style-to-the-link">
          Updated Code: Adding <code>style</code> to the Link
        </h3>
        <pre><code class="typescript language-typescript">import type { Node, Parent } from 'unist'; // Import types for Node and Parent
import type { Heading, Link, Text } from 'mdast'; // Import specific node types from mdast
import { visit } from 'unist-util-visit';

const toc: Record&lt;string, unknown&gt; = {}; // Add a type for `toc` if needed

export const remarkToc = () =&gt; {
  return (tree: Parent) =&gt; {
    // Ensure the tree is a Parent node (it has `children`)
    visit(tree, 'heading', (node: Heading, index: number | null, parent: Parent | null) =&gt; {
      // Define the div node with proper types
      const divNode: Parent = {
        type: 'div', // Custom node type
        data: {
          hName: 'div', // Rendered as &lt;div&gt; in HTML
          hProperties: { className: 'dynamic-div' }, // Add attributes
        },
        children: [
          {
            type: 'link', // Link node
            url: '#test', // Target URL
            data: {
              hProperties: {
                style: { color: 'red', textDecoration: 'none' }, // Add inline styles
              },
            },
            children: [
              {
                type: 'text', // Text node
                value: 'This content is dynamically generated.', // Text content
              } as Text, // Explicit type for text node
            ],
          } as Link, // Explicit type for link node
        ],
      };

      console.log('here');

      // Add the div node to the end of the tree
      (tree as Parent).children.push(divNode); // Cast `tree` to Parent to access `children`
    });
  };
};</code></pre>
        <hr />
        <h3 id="explanation">Explanation</h3>
        <ol>
          <li>
            <p>
              <strong
                >Adding <code>data.hProperties</code> to the Link Node</strong
              >:
            </p>
            <ul>
              <li>
                The <code>data</code> property allows you to add rendering
                metadata, such as <code>hProperties</code>, which is used by
                <strong>remark-html</strong> or other rendering plugins.
              </li>
              <li>
                In <code>hProperties</code>, the <code>style</code> attribute is
                added as an object.
              </li>
            </ul>
          </li>
          <li>
            <p><strong>Style Object</strong>:</p>
            <ul>
              <li>
                The <code>style</code> object can include any CSS properties:
              </li>
            </ul>
            <pre><code class="typescript language-typescript"> style: { color: 'red', textDecoration: 'none' }</code></pre>
          </li>
          <li>
            <p>
              <strong>Rendering with <code>remark-html</code></strong
              >:
            </p>
            <ul>
              <li>
                If you use <strong>remark-html</strong>, it will render the
                <code>style</code> object as an inline
                <code>style</code> attribute in the HTML.
              </li>
            </ul>
          </li>
        </ol>
        <hr />
        <h3 id="example-input-markdown">Example Input Markdown:</h3>
        <pre><code class="markdown language-markdown"># Heading</code></pre>
        <h3 id="example-output-html">Example Output HTML:</h3>
        <p>
          If you pass the tree to <code>remark-html</code>, the resulting HTML
          will look like this:
        </p>
        <pre><code class="html language-html">&lt;h1&gt;Heading&lt;/h1&gt;
&lt;div class="dynamic-div"&gt;
  &lt;a href="#test" style="color: red; text-decoration: none;"&gt;This content is dynamically generated.&lt;/a&gt;
&lt;/div&gt;</code></pre>
        <hr />
        <h3 id="dependencies">Dependencies</h3>
        <p>
          Make sure you have <strong>remark-html</strong> installed if you want
          to convert the AST to HTML:
        </p>
        <pre><code class="bash language-bash">npm install remark-html</code></pre>
        <p>Use it like this:</p>
        <pre><code class="typescript language-typescript">import { remark } from 'remark';
import remarkHtml from 'remark-html';
import { remarkToc } from './path-to-your-plugin';

remark()
  .use(remarkToc)
  .use(remarkHtml)
  .process('# Heading', (err, file) =&gt; {
    if (err) throw err;
    console.log(String(file)); // Outputs the final HTML
  });</code></pre>
        <hr />
        <p>
          Let me know if you have any further questions or need more examples!
          🚀
        </p>
      </div>
      <div class="bubble user">
        fix this code for me import { visit } from 'unist-util-visit'; import
        type { Parent } from 'unist'; import type { Link, List, ListItem,
        Heading } from 'mdast'; const toc: Heading[] = []; type DivNode = {
        type: 'div'; data: { hName: 'div'; hProperties: { className: string } };
        children: List; }; export const remarkToc = () =&gt; { return (tree:
        Parent) =&gt; { visit(tree, 'heading', (node: Heading) =&gt; {
        toc.push(node); }); // ! nav const div: DivNode = { type: 'div', data: {
        hName: 'div', hProperties: { className: 'table-of-contents' }, },
        children: { type: 'list', children: [ { type: 'listItem', children: [ {
        type: 'paragraph', children: [ { type: 'link', url: '#test', children:
        [{ type: 'text', value: 'text' }] }, ], }, ], }, ], }, };
        tree.children.unshift(div); }; };
      </div>
      <div class="bubble">
        <p>
          Here’s the fixed and improved version of your code. It includes proper
          TypeScript type adjustments, fixes type mismatches, and ensures
          <code>div</code> is properly added to the tree.
        </p>
        <h3 id="fixed-code">Fixed Code</h3>
        <pre><code class="typescript language-typescript">import { visit } from 'unist-util-visit';

import type { Parent } from 'unist';
import type { Link, List, ListItem, Heading, Paragraph, Text } from 'mdast';

// Collect headings for Table of Contents
const toc: Heading[] = [];

// Define the custom DivNode type
type DivNode = {
  type: 'div';
  data: { hName: 'div'; hProperties: { className: string } };
  children: List;
};

export const remarkToc = () =&gt; {
  return (tree: Parent) =&gt; {
    // Collect all headings
    visit(tree, 'heading', (node: Heading) =&gt; {
      toc.push(node);
    });

    // Define the div node with a nested list structure
    const div: DivNode = {
      type: 'div',
      data: {
        hName: 'div',
        hProperties: { className: 'table-of-contents' },
      },
      children: {
        type: 'list',
        children: [
          {
            type: 'listItem',
            children: [
              {
                type: 'paragraph',
                children: [
                  {
                    type: 'link',
                    url: '#test',
                    children: [
                      {
                        type: 'text',
                        value: 'text',
                      } as Text,
                    ],
                  } as Link,
                ],
              } as Paragraph,
            ],
          } as ListItem,
        ],
      },
    };

    // Add the div node to the beginning of the tree
    tree.children.unshift(div as unknown as Parent); // Cast div to Parent to satisfy TypeScript
  };
};</code></pre>
        <hr />
        <h3 id="key-changes-and-fixes">Key Changes and Fixes</h3>
        <ol>
          <li>
            <p>
              <strong>Fixed Type for <code>div.children</code></strong
              >:
            </p>
            <ul>
              <li>
                The <code>children</code> property of <code>DivNode</code> is
                defined as <code>List</code>. Previously, there was a type
                mismatch due to incorrect or missing child node definitions.
              </li>
            </ul>
          </li>
          <li>
            <p>
              <strong
                >Typed Inner Nodes (<code>Text</code>, <code>Link</code>,
                <code>Paragraph</code>, <code>ListItem</code>, and
                <code>List</code>)</strong
              >:
            </p>
            <ul>
              <li>
                Explicitly defined types for each child node to ensure correct
                structure:
                <ul>
                  <li><code>Text</code>: Represents plain text.</li>
                  <li>
                    <code>Link</code>: Represents links with
                    <code>url</code> and <code>children</code>.
                  </li>
                  <li><code>Paragraph</code>: Wraps text or inline content.</li>
                  <li><code>ListItem</code>: Represents list items.</li>
                  <li><code>List</code>: Represents the list itself.</li>
                </ul>
              </li>
            </ul>
          </li>
          <li>
            <p>
              <strong>Proper Type for <code>div</code></strong
              >:
            </p>
            <ul>
              <li>
                Defined the <code>div</code> as a <code>DivNode</code> and
                ensured it adhered to the <code>Parent</code> type with correct
                children.
              </li>
            </ul>
          </li>
          <li>
            <p>
              <strong
                >Casting <code>div</code> for
                <code>tree.children.unshift</code></strong
              >:
            </p>
            <ul>
              <li>
                The <code>div</code> node is cast to <code>Parent</code> to
                satisfy TypeScript, as <code>tree.children</code> expects
                <code>Parent</code>-typed nodes.
              </li>
            </ul>
          </li>
          <li>
            <p><strong>Simplified Logic</strong>:</p>
            <ul>
              <li>
                Focused on creating a valid MDAST-compliant structure for the
                <code>div</code>.
              </li>
            </ul>
          </li>
        </ol>
        <hr />
        <h3 id="example-input-markdown">Example Input Markdown</h3>
        <pre><code class="markdown language-markdown"># Heading 1

Some content.

## Heading 2

More content.</code></pre>
        <h3 id="example-output-ast">Example Output AST</h3>
        <p>
          The resulting AST will include the <code>div</code> node at the
          beginning:
        </p>
        <pre><code class="json language-json">{
  "type": "root",
  "children": [
    {
      "type": "div",
      "data": {
        "hName": "div",
        "hProperties": {
          "className": "table-of-contents"
        }
      },
      "children": {
        "type": "list",
        "children": [
          {
            "type": "listItem",
            "children": [
              {
                "type": "paragraph",
                "children": [
                  {
                    "type": "link",
                    "url": "#test",
                    "children": [
                      {
                        "type": "text",
                        "value": "text"
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ]
      }
    },
    {
      "type": "heading",
      "depth": 1,
      "children": [
        {
          "type": "text",
          "value": "Heading 1"
        }
      ]
    },
    {
      "type": "heading",
      "depth": 2,
      "children": [
        {
          "type": "text",
          "value": "Heading 2"
        }
      ]
    }
  ]
}</code></pre>
        <hr />
        <h3 id="example-output-markdown-with-remark-html">
          Example Output Markdown (with <code>remark-html</code>)
        </h3>
        <p>
          If rendered to HTML using <code>remark-html</code>, the output will
          be:
        </p>
        <pre><code class="html language-html">&lt;div class="table-of-contents"&gt;
  &lt;ul&gt;
    &lt;li&gt;
      &lt;p&gt;&lt;a href="#test"&gt;text&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
  &lt;/ul&gt;
&lt;/div&gt;
&lt;h1&gt;Heading 1&lt;/h1&gt;
&lt;p&gt;Some content.&lt;/p&gt;
&lt;h2&gt;Heading 2&lt;/h2&gt;
&lt;p&gt;More content.&lt;/p&gt;</code></pre>
        <hr />
        <h3 id="notes">Notes</h3>
        <ul>
          <li>
            <strong>Dynamic Links</strong>:
            <ul>
              <li>
                Replace the <code>url</code> in <code>div.children</code> with
                dynamically generated IDs based on the collected
                <code>toc</code> array.
              </li>
            </ul>
          </li>
          <li>
            <strong>Dynamic TOC Content</strong>:
            <ul>
              <li>
                Use the <code>toc</code> array to generate the list items
                dynamically based on the headings collected.
              </li>
            </ul>
          </li>
        </ul>
        <p>
          Let me know if you need help with dynamic generation or further
          modifications! 🚀
        </p>
      </div>
      <div class="bubble user">
        This is my implementation and the problem is that the TOC of the
        previously visited pages gets shown upon navigation to another page
      </div>
      <div class="bubble">
        <p>
          The issue where the Table of Contents (TOC) from previously visited
          pages persists across navigations is likely due to the
          <code>toc</code> array being declared outside the
          <code>remarkToc</code>
        </p>
      </div>
      <div class="bubble user">
        import { visit } from 'unist-util-visit'; // * data const toc: Heading[]
        = []; // * types import type { Parent } from 'unist'; import type {
        List, Heading } from 'mdast'; type DepthRange = { min?:
        Heading['depth']; max?: Heading['depth'] }; type NavNode = { type:
        'nav'; children: [List]; data: { hName: 'nav'; hProperties: { className:
        string } }; }; export const remarkToc = (depthRange: DepthRange = {})
        =&gt; { const { min = 2, max = 3 } = depthRange; toc.length = 0; return
        (tree: Parent) =&gt; { visit(tree, 'heading', (node: Heading) =&gt; { if
        (node.depth &gt;= min &amp;&amp; node.depth &lt;= max) toc.push(node);
        }); const navNode: NavNode = { type: 'nav', data: { hName: 'nav',
        hProperties: { className: 'table-of-contents' }, }, children: [ { type:
        'list', children: toc.map(heading =&gt; ({ type: 'listItem', data: {
        hProperties: { className: `lvl-${heading.depth}` } }, children: [ {
        type: 'paragraph', children: [{ type: 'link', url: '#test', children:
        heading.children }], }, ], })), }, ], }; tree.children.unshift(navNode);
        }; };
      </div>
      <div class="bubble">
        <p>
          The issue arises because the <code>toc</code> array is declared as a
          global variable, and its content persists across navigations, causing
          the Table of Contents (TOC) of previously visited pages to appear on
          subsequent pages. To resolve this, ensure the <code>toc</code> array
          is reset or scoped properly within the function.
        </p>
        <h3 id="fixed-implementation">Fixed Implementation</h3>
        <p>
          Here's the updated implementation where the <code>toc</code> array is
          scoped to the <code>remarkToc</code> function:
        </p>
        <pre><code class="typescript language-typescript">import { visit } from 'unist-util-visit';

// * types
import type { Parent } from 'unist';
import type { List, Heading } from 'mdast';

type DepthRange = { min?: Heading['depth']; max?: Heading['depth'] };

type NavNode = {
  type: 'nav';
  children: [List];
  data: { hName: 'nav'; hProperties: { className: string } };
};

export const remarkToc = (depthRange: DepthRange = {}) =&gt; {
  const { min = 2, max = 3 } = depthRange;

  return (tree: Parent) =&gt; {
    const toc: Heading[] = []; // Declare toc inside the function to ensure it's reset for every page

    visit(tree, 'heading', (node: Heading) =&gt; {
      if (node.depth &gt;= min &amp;&amp; node.depth &lt;= max) toc.push(node);
    });

    const navNode: NavNode = {
      type: 'nav',
      data: {
        hName: 'nav',
        hProperties: { className: 'table-of-contents' },
      },
      children: [
        {
          type: 'list',
          children: toc.map((heading) =&gt; ({
            type: 'listItem',
            data: { hProperties: { className: `lvl-${heading.depth}` } },
            children: [
              {
                type: 'paragraph',
                children: [{ type: 'link', url: '#test', children: heading.children }],
              },
            ],
          })),
        },
      ],
    };

    tree.children.unshift(navNode);
  };
};</code></pre>
        <hr />
        <h3 id="key-changes-and-fixes">Key Changes and Fixes</h3>
        <ol>
          <li>
            <p>
              <strong>Scoped <code>toc</code> Array</strong>:
            </p>
            <ul>
              <li>
                Moved the <code>toc</code> array declaration inside the
                <code>return</code> function of <code>remarkToc</code>.
              </li>
              <li>
                This ensures the <code>toc</code> is reset for every execution
                of the plugin, resolving the issue of stale data.
              </li>
            </ul>
          </li>
          <li>
            <p><strong>Dynamic Depth Range</strong>:</p>
            <ul>
              <li>
                The <code>depthRange</code> parameter with <code>min</code> and
                <code>max</code> values works as expected. This code ensures
                only headings within the specified range are added to the TOC.
              </li>
            </ul>
          </li>
          <li>
            <p><strong>Correct List Generation</strong>:</p>
            <ul>
              <li>
                Each <code>heading</code> is converted to a
                <code>listItem</code> with a <code>paragraph</code> containing a
                <code>link</code>.
              </li>
              <li>
                The <code>children</code> of the heading are reused for the link
                text, and the <code>url</code> can be dynamically generated
                (e.g., based on an <code>id</code> or slug).
              </li>
            </ul>
          </li>
        </ol>
        <hr />
        <h3 id="example-usage">Example Usage</h3>
        <h4 id="input-markdown">Input Markdown:</h4>
        <pre><code class="markdown language-markdown"># Title

## Section 1

Content here.

### Subsection 1.1

Content here.

## Section 2

Content here.</code></pre>
        <h4 id="output-ast">Output AST:</h4>
        <p>
          The TOC is correctly inserted as a <code>nav</code> node at the
          beginning:
        </p>
        <pre><code class="json language-json">{
  "type": "root",
  "children": [
    {
      "type": "nav",
      "data": {
        "hName": "nav",
        "hProperties": {
          "className": "table-of-contents"
        }
      },
      "children": [
        {
          "type": "list",
          "children": [
            {
              "type": "listItem",
              "data": {
                "hProperties": {
                  "className": "lvl-2"
                }
              },
              "children": [
                {
                  "type": "paragraph",
                  "children": [
                    {
                      "type": "link",
                      "url": "#test",
                      "children": [
                        {
                          "type": "text",
                          "value": "Section 1"
                        }
                      ]
                    }
                  ]
                }
              ]
            },
            {
              "type": "listItem",
              "data": {
                "hProperties": {
                  "className": "lvl-3"
                }
              },
              "children": [
                {
                  "type": "paragraph",
                  "children": [
                    {
                      "type": "link",
                      "url": "#test",
                      "children": [
                        {
                          "type": "text",
                          "value": "Subsection 1.1"
                        }
                      ]
                    }
                  ]
                }
              ]
            }
          ]
        }
      ]
    },
    {
      "type": "heading",
      "depth": 1,
      "children": [
        {
          "type": "text",
          "value": "Title"
        }
      ]
    }
  ]
}</code></pre>
        <hr />
        <h3 id="why-this-fix-works">Why This Fix Works</h3>
        <ol>
          <li>
            <p>
              <strong><code>toc</code> Scoped to Each Invocation</strong>:
            </p>
            <ul>
              <li>
                Each invocation of <code>remarkToc</code> (e.g., for a new
                Markdown file) initializes a fresh <code>toc</code> array,
                avoiding stale data from previous invocations.
              </li>
            </ul>
          </li>
          <li>
            <p><strong>Independent State</strong>:</p>
            <ul>
              <li>
                By scoping <code>toc</code> locally, each page has an
                independent Table of Contents, unaffected by previous pages.
              </li>
            </ul>
          </li>
        </ol>
        <hr />
        <p>
          Let me know if you have further questions or need additional
          assistance! 🚀
        </p>
      </div>
      <div class="bubble user">
        My plugin is complete how to then publish it?
      </div>
      <div class="bubble">
        <p>
          Publishing your Remark plugin involves several steps to ensure it's
          available on npm and easily usable by others. Here's a step-by-step
          guide:
        </p>
        <hr />
        <h3 id="1-prepare-your-plugin-for-publishing">
          1. <strong>Prepare Your Plugin for Publishing</strong>
        </h3>
        <h4 id="a-ensure-your-code-is-ready">
          a. <strong>Ensure Your Code is Ready</strong>
        </h4>
        <ul>
          <li>Verify that your plugin works as expected.</li>
          <li>Clean up unnecessary code or comments.</li>
          <li>Ensure your plugin exports the main function properly, e.g.:</li>
        </ul>
        <pre><code class="javascript language-javascript">  module.exports = remarkToc;</code></pre>
        <h4 id="b-add-a-readmemd">
          b. <strong>Add a <code>README.md</code></strong>
        </h4>
        <ul>
          <li>
            Include documentation on how to use the plugin:
            <ul>
              <li>What the plugin does.</li>
              <li>How to install it.</li>
              <li>Example usage.</li>
            </ul>
          </li>
          <li>Example <code>README.md</code>:</li>
        </ul>
        <pre><code class="markdown language-markdown">  # remark-toc

  A Remark plugin to generate a Table of Contents (TOC) for Markdown files.

  ## Installation</code></pre>
        <p>
          bash<br />
          npm install remark-toc
        </p>
        <pre><code>  ## Usage</code></pre>
        <p>
          javascript<br />
          const remark = require('remark');<br />
          const remarkToc = require('remark-toc');
        </p>
        <p>
          remark()<br />
          .use(remarkToc, { min: 2, max: 3 })<br />
          .process('# Title\n\n## Section 1\n\n### Subsection 1.1', (err, file)
          =&gt; {<br />
          if (err) throw err;<br />
          console.log(String(file));<br />
          });
        </p>
        <pre><code>  ## Options

  - `min`: Minimum heading depth to include in the TOC.
  - `max`: Maximum heading depth to include in the TOC.</code></pre>
        <h4 id="c-add-a-packagejson">
          c. <strong>Add a <code>package.json</code></strong>
        </h4>
        <p>If you don't already have one, create it using:</p>
        <pre><code class="bash language-bash">npm init</code></pre>
        <p>Key fields to include:</p>
        <ul>
          <li>
            <strong>Name</strong>: A unique name for your package (e.g.,
            <code>remark-toc</code>).
          </li>
          <li>
            <strong>Version</strong>: Start with <code>1.0.0</code> for an
            initial release.
          </li>
          <li>
            <strong>Description</strong>: A short description of your plugin.
          </li>
          <li>
            <strong>Main</strong>: The entry point file (e.g.,
            <code>index.js</code>).
          </li>
          <li>
            <strong>Keywords</strong>: Add relevant keywords to make your plugin
            discoverable (e.g., <code>remark</code>, <code>markdown</code>,
            <code>plugin</code>, <code>toc</code>).
          </li>
          <li>
            <strong>Repository</strong>: If hosted on GitHub, link to the
            repository.
          </li>
          <li>
            <strong>Dependencies</strong>: Ensure
            <code>unist-util-visit</code> or other dependencies are listed.
          </li>
        </ul>
        <p>Example <code>package.json</code>:</p>
        <pre><code class="json language-json">{
  "name": "remark-toc",
  "version": "1.0.0",
  "description": "A Remark plugin to generate a Table of Contents (TOC) for Markdown files.",
  "main": "index.js",
  "keywords": ["remark", "markdown", "plugin", "toc"],
  "repository": {
    "type": "git",
    "url": "https://github.com/yourusername/remark-toc"
  },
  "author": "Your Name &lt;your.email@example.com&gt;",
  "license": "MIT",
  "dependencies": {
    "unist-util-visit": "^4.0.0"
  }
}</code></pre>
        <hr />
        <h3 id="2-publish-to-npm">2. <strong>Publish to npm</strong></h3>
        <h4 id="a-login-to-npm">a. <strong>Login to npm</strong></h4>
        <p>
          If you don’t already have an npm account,
          <a href="https://www.npmjs.com/signup">create one here</a>.
        </p>
        <p>Log in to npm:</p>
        <pre><code class="bash language-bash">npm login</code></pre>
        <h4 id="b-publish-your-plugin">
          b. <strong>Publish Your Plugin</strong>
        </h4>
        <p>Run:</p>
        <pre><code class="bash language-bash">npm publish</code></pre>
        <ul>
          <li>
            This will publish your plugin to npm under the name specified in
            <code>package.json</code>.
          </li>
          <li>
            If you want to scope your package (e.g.,
            <code>@yourusername/remark-toc</code>), prefix the name in
            <code>package.json</code> with <code>@yourusername/</code>.
          </li>
        </ul>
        <h4 id="c-verify-the-package">
          c. <strong>Verify the Package</strong>
        </h4>
        <p>
          Search for your package on npm:
          <a href="https://www.npmjs.com/">https://www.npmjs.com/</a>.
        </p>
        <hr />
        <h3 id="3-share-and-maintain-your-plugin">
          3. <strong>Share and Maintain Your Plugin</strong>
        </h3>
        <h4 id="a-share-your-plugin">a. <strong>Share Your Plugin</strong></h4>
        <ul>
          <li>
            Announce it in relevant communities, like:
            <ul>
              <li>
                <a href="https://github.com/unifiedjs">unified</a> ecosystem.
              </li>
              <li>Markdown-related or open-source communities.</li>
            </ul>
          </li>
          <li>Add badges to your <code>README.md</code>:</li>
        </ul>
        <pre><code class="markdown language-markdown">  ![npm](https://img.shields.io/npm/v/remark-toc)</code></pre>
        <h4 id="b-fix-bugs-and-update">
          b. <strong>Fix Bugs and Update</strong>
        </h4>
        <ul>
          <li>
            As users report issues or suggest features, update your plugin.
          </li>
          <li>
            Bump the version number following
            <a href="https://semver.org/">semantic versioning</a>:
            <ul>
              <li><code>1.0.1</code>: For patches.</li>
              <li><code>1.1.0</code>: For minor feature updates.</li>
              <li><code>2.0.0</code>: For breaking changes.</li>
            </ul>
          </li>
        </ul>
        <h4 id="c-automate-tests">c. <strong>Automate Tests</strong></h4>
        <p>
          Add tests using a framework like <code>jest</code> to ensure future
          changes don’t introduce bugs.
        </p>
        <hr />
        <h3 id="4-optional-publish-on-github">
          4. <strong>Optional: Publish on GitHub</strong>
        </h3>
        <h4 id="a-create-a-github-repository">
          a. <strong>Create a GitHub Repository</strong>
        </h4>
        <ul>
          <li>Push your code to GitHub.</li>
          <li>
            Include instructions in your <code>README.md</code> for users to
            contribute.
          </li>
        </ul>
        <h4 id="b-link-github-to-npm">
          b. <strong>Link GitHub to npm</strong>
        </h4>
        <ul>
          <li>
            Add the GitHub repository to your <code>package.json</code> under
            <code>repository</code>.
          </li>
          <li>Example:</li>
        </ul>
        <pre><code class="json language-json">  "repository": {
    "type": "git",
    "url": "https://github.com/yourusername/remark-toc"
  }</code></pre>
        <hr />
        <p>Let me know if you need help with any specific step! 🚀</p>
      </div>
      <div class="bubble user">Does it need to be built?</div>
      <div class="bubble">
        <p>
          Whether your <strong>Remark plugin</strong> needs to be built depends
          on the language and tools you use to write it:
        </p>
        <ol>
          <li>
            <p><strong>Pure JavaScript (No Build Required)</strong>:</p>
            <ul>
              <li>
                If your plugin is written in plain JavaScript (e.g.,
                <code>index.js</code>) and compatible with Node.js (ES5 or ES6
                syntax), <strong>you don’t need to build it</strong>.
              </li>
              <li>Simply publish the code as-is to npm.</li>
            </ul>
            <p>Example:</p>
          </li>
        </ol>
        <pre><code class="javascript language-javascript">   module.exports = function remarkToc() {
     return (tree) =&gt; {
       // Plugin logic
     };
   };</code></pre>
        <p>Steps:</p>
        <ul>
          <li>
            Ensure <code>main</code> in <code>package.json</code> points to your
            entry file (e.g., <code>index.js</code>).
          </li>
          <li>Run <code>npm publish</code>.</li>
        </ul>
        <hr />
        <ol start="2">
          <li>
            <p><strong>TypeScript (Build Required)</strong>:</p>
            <ul>
              <li>
                If your plugin is written in TypeScript, it needs to be
                transpiled to JavaScript before publishing.
              </li>
              <li>
                Tools like <code>tsc</code> (TypeScript Compiler) handle this.
              </li>
            </ul>
            <p>Steps:</p>
            <ol>
              <li>Add a <code>tsconfig.json</code> to configure TypeScript:</li>
            </ol>
            <pre><code class="json language-json">  {
    "compilerOptions": {
      "module": "commonjs",
      "target": "es2017",
      "outDir": "dist",
      "strict": true,
      "declaration": true
    },
    "include": ["src"]
  }</code></pre>
            <ol start="2">
              <li>Organize your project:</li>
            </ol>
            <pre><code>  src/
  └── index.ts (your plugin code)
  dist/
  └── (generated JavaScript files after build)</code></pre>
            <ol start="3">
              <li>Build the plugin:</li>
            </ol>
            <pre><code class="bash language-bash">  npx tsc</code></pre>
            <ol start="4">
              <li>
                Publish the <code>dist</code> folder to npm:
                <ul>
                  <li>
                    Add <code>"main": "dist/index.js"</code> in
                    <code>package.json</code>.
                  </li>
                  <li>
                    Exclude <code>src</code> in the <code>.npmignore</code> file
                    or ensure <code>src</code> is not included in the npm
                    package.
                  </li>
                </ul>
              </li>
            </ol>
          </li>
        </ol>
        <hr />
        <ol start="3">
          <li>
            <p><strong>Modern JavaScript (ESM or ESNext)</strong>:</p>
            <ul>
              <li>
                If your plugin uses modern JavaScript features (e.g.,
                <code>import/export</code> or ES modules), you may need to
                transpile it for compatibility with older environments.
              </li>
            </ul>
            <p>Use <strong>Babel</strong> or another build tool:</p>
            <ul>
              <li>Add a <code>.babelrc</code> file:</li>
            </ul>
            <pre><code class="json language-json"> {
   "presets": ["@babel/preset-env"]
 }</code></pre>
            <ul>
              <li>Transpile the code:</li>
            </ul>
            <pre><code class="bash language-bash"> npx babel src --out-dir dist</code></pre>
            <ul>
              <li>
                Ensure <code>package.json</code> points to the transpiled files:
              </li>
            </ul>
            <pre><code class="json language-json"> "main": "dist/index.js",
 "type": "commonjs"</code></pre>
          </li>
        </ol>
        <hr />
        <ol start="4">
          <li>
            <strong>Unified Plugins and Build Systems</strong>:
            <ul>
              <li>
                Many <strong>unified</strong> ecosystem plugins (e.g.,
                <code>remark-*</code>) are written in plain JavaScript or
                TypeScript. Typically, they don’t require extensive builds
                unless you use advanced tooling.
              </li>
              <li>
                If your plugin uses advanced bundling (e.g., for web
                compatibility), you might use tools like <code>rollup</code> or
                <code>esbuild</code>.
              </li>
            </ul>
          </li>
        </ol>
        <hr />
        <h3 id="summary">Summary</h3>
        <table>
          <thead>
            <tr>
              <th id="**language/setup**"><strong>Language/Setup</strong></th>
              <th id="**build_required**"><strong>Build Required</strong></th>
              <th id="**action**"><strong>Action</strong></th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td>Plain JavaScript</td>
              <td>No</td>
              <td>Publish directly.</td>
            </tr>
            <tr>
              <td>TypeScript</td>
              <td>Yes</td>
              <td>Transpile with <code>tsc</code>.</td>
            </tr>
            <tr>
              <td>Modern JavaScript (ESM)</td>
              <td>Yes (optional)</td>
              <td>Transpile with Babel if necessary.</td>
            </tr>
            <tr>
              <td>Using Advanced Bundlers</td>
              <td>Yes</td>
              <td>Use <code>rollup</code> or <code>esbuild</code>.</td>
            </tr>
          </tbody>
        </table>
        <p>Let me know if you’d like help setting up a build process! 🚀</p>
      </div>
    </div>
  </body>
</html>
